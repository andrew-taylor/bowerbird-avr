<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>MyUSB Library: Endpoint.h File Reference</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
<link href="../../tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.5 -->
<script type="text/javascript">
<!--
function changeDisplayState (e){
  var num=this.id.replace(/[^[0-9]/g,'');
  var button=this.firstChild;
  var sectionDiv=document.getElementById('dynsection'+num);
  if (sectionDiv.style.display=='none'||sectionDiv.style.display==''){
    sectionDiv.style.display='block';
    button.src='../../open.gif';
  }else{
    sectionDiv.style.display='none';
    button.src='../../closed.gif';
  }
}
function initDynSections(){
  var divs=document.getElementsByTagName('div');
  var sectionCounter=1;
  for(var i=0;i<divs.length-1;i++){
    if(divs[i].className=='dynheader'&&divs[i+1].className=='dynsection'){
      var header=divs[i];
      var section=divs[i+1];
      var button=header.firstChild;
      if (button!='IMG'){
        divs[i].insertBefore(document.createTextNode(' '),divs[i].firstChild);
        button=document.createElement('img');
        divs[i].insertBefore(button,divs[i].firstChild);
      }
      header.style.cursor='pointer';
      header.onclick=changeDisplayState;
      header.id='dynheader'+sectionCounter;
      button.src='../../closed.gif';
      section.id='dynsection'+sectionCounter;
      section.style.display='none';
      section.style.marginLeft='14px';
      sectionCounter++;
    }
  }
}
window.onload = initDynSections;
-->
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="../../main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="../../pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="../../classes.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="../../files.html"><span>Files</span></a></li>
      <li><a href="../../dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="../../dir_2e1fbef791c6441b28631243cfb4eaa5.html">MyUSB</a>&nbsp;&raquo&nbsp;<a class="el" href="../../dir_88a6e91c5675e76375b47b277a58e3e8.html">Drivers</a>&nbsp;&raquo&nbsp;<a class="el" href="../../dir_cf4f163638ad68cd11bd930d84c7b552.html">USB</a>&nbsp;&raquo&nbsp;<a class="el" href="../../dir_b1006f5156f0bb4cb34454f31590fa7a.html">LowLevel</a>
  </div>
</div>
<div class="contents">
<h1>Endpoint.h File Reference</h1><code>#include &lt;avr/io.h&gt;</code><br>
<code>#include &lt;stdbool.h&gt;</code><br>
<code>#include &quot;<a class="el" href="../../d3/dfe/a00025.html">../../../Common/Common.h</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="../../d9/dec/a00090.html">../HighLevel/USBTask.h</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="../../d4/d63/a00082.html">StreamCallbacks.h</a>&quot;</code><br>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d3a/a00040.html#b011e2ee1e9f55b60cda3dbc79b95961">ENDPOINT_DIR_OUT</a>&nbsp;&nbsp;&nbsp;0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d3a/a00040.html#be19393ecfcac9ea1ee8c6b3dc87830a">ENDPOINT_DIR_IN</a>&nbsp;&nbsp;&nbsp;(1 &lt;&lt; EPDIR)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d3a/a00040.html#e4bc67200452560b253e3f01acae9373">ENDPOINT_BANK_SINGLE</a>&nbsp;&nbsp;&nbsp;0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d3a/a00040.html#417e96e8278a9c41e846fff106ce5791">ENDPOINT_BANK_DOUBLE</a>&nbsp;&nbsp;&nbsp;(1 &lt;&lt; EPBK0)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d3a/a00040.html#5735655e855a6da7ee2e48084c10d9d6">ENDPOINT_CONTROLEP</a>&nbsp;&nbsp;&nbsp;0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d3a/a00040.html#ebe9cfe97e9292e5e8cfba9885bbd901">ENDPOINT_CONTROLEP_DEFAULT_SIZE</a>&nbsp;&nbsp;&nbsp;8</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d3a/a00040.html#6ee88e6fd992e2a064923871980b493d">ENDPOINT_EPNUM_MASK</a>&nbsp;&nbsp;&nbsp;0b111</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d3a/a00040.html#afb7a906223f76d344a8ad05bf066f4c">ENDPOINT_EPSIZE_MASK</a>&nbsp;&nbsp;&nbsp;0x7FF</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d3a/a00040.html#3e245962bd3c397a47d8cfde79d6c2a2">ENDPOINT_MAX_ENDPOINTS</a>&nbsp;&nbsp;&nbsp;7</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d3a/a00040.html#0c326f3e68fd43f00c9f26b51b71c274">ENDPOINT_MAX_SIZE</a>&nbsp;&nbsp;&nbsp;256</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d3a/a00040.html#2ba13d7ad8aaa339d0ca1b357bf2fabc">ENDPOINT_INT_SETUP</a>&nbsp;&nbsp;&nbsp;UEIENX, (1 &lt;&lt; RXSTPE), UEINTX, (1 &lt;&lt; RXSTPI)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d3a/a00040.html#00a6a6e9368105863364e410d1fcecb2">ENDPOINT_INT_IN</a>&nbsp;&nbsp;&nbsp;UEIENX, (1 &lt;&lt; TXINE) , UEINTX, (1 &lt;&lt; TXINI)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d3a/a00040.html#c48adc496b7ab8a89a50cb27eff25bee">ENDPOINT_INT_OUT</a>&nbsp;&nbsp;&nbsp;UEIENX, (1 &lt;&lt; RXOUTE), UEINTX, (1 &lt;&lt; RXOUTI)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d3a/a00040.html#2036a748148fba4da9ba50c1cb59d674">Endpoint_BytesInEndpoint</a>()&nbsp;&nbsp;&nbsp;UEBCX</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d3a/a00040.html#4b624a8716463aac308149c38bb6323f">Endpoint_GetCurrentEndpoint</a>()&nbsp;&nbsp;&nbsp;(UENUM   &amp;   ENDPOINT_EPNUM_MASK)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d3a/a00040.html#9bbfbc4d395831ee7d9bd6316ef603ce">Endpoint_SelectEndpoint</a>(epnum)&nbsp;&nbsp;&nbsp;MACROS{ UENUM    =  epnum;                         }MACROE</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d3a/a00040.html#1648a4932e17380fa8dde89f5d952911">Endpoint_ResetFIFO</a>(epnum)&nbsp;&nbsp;&nbsp;MACROS{ UERST    =  (1 &lt;&lt; epnum); UERST = 0;       }MACROE</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d3a/a00040.html#c3147c22cb57edf6e96e8106f6752696">Endpoint_EnableEndpoint</a>()&nbsp;&nbsp;&nbsp;MACROS{ UECONX  |=  (1 &lt;&lt; EPEN);                   }MACROE</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d3a/a00040.html#fc1ca931a94f9ae403985dfe6fb491e5">Endpoint_DisableEndpoint</a>()&nbsp;&nbsp;&nbsp;MACROS{ UECONX  &amp;= ~(1 &lt;&lt; EPEN);                   }MACROE</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d3a/a00040.html#368f9de07439857a318a949edbcd9c79">Endpoint_IsEnabled</a>()&nbsp;&nbsp;&nbsp;((UECONX  &amp;   (1 &lt;&lt; EPEN)) ? true : false)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d3a/a00040.html#7d816c2bf5bb331ebbf6f2857f563e21">Endpoint_ReadWriteAllowed</a>()&nbsp;&nbsp;&nbsp;((UEINTX  &amp; (1 &lt;&lt; RWAL)) ? true : false)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d3a/a00040.html#64d277eb0702f0ffd009e201393dc1e3">Endpoint_ConfigureEndpoint</a>(num, type, dir, size, banks)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d3a/a00040.html#9139daacd1341586aa08015191f903a2">Endpoint_IsConfigured</a>()&nbsp;&nbsp;&nbsp;((UESTA0X &amp; (1 &lt;&lt; CFGOK)) ? true : false)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d3a/a00040.html#6d7af6c9eb867d04de9fc7c0e7be1c04">Endpoint_GetEndpointInterrupts</a>()&nbsp;&nbsp;&nbsp;UEINT</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d3a/a00040.html#f1211509b0c301a613b8c03113563053">Endpoint_ClearEndpointInterrupt</a>(n)&nbsp;&nbsp;&nbsp;MACROS{ UEINT   &amp;= ~(1 &lt;&lt; n);                     }MACROE</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d3a/a00040.html#e2347441f26d71d15b96f084a6dcf747">Endpoint_HasEndpointInterrupted</a>(n)&nbsp;&nbsp;&nbsp;((UEINT   &amp;   (1 &lt;&lt; n)) ? true : false)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d3a/a00040.html#41d8837f1719203a95724dccc90ec2ee">Endpoint_ClearCurrentBank</a>()&nbsp;&nbsp;&nbsp;MACROS{ UEINTX  &amp;= ~(1 &lt;&lt; FIFOCON);               }MACROE</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d3a/a00040.html#2ed21d9682bd7e5f602923f94ac54333">Endpoint_IsSetupINReady</a>()&nbsp;&nbsp;&nbsp;((UEINTX  &amp; (1 &lt;&lt; TXINI))  ? true : false)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d3a/a00040.html#ce5510430ebc0cc8f891acdb1c2a9be9">Endpoint_IsSetupOUTReceived</a>()&nbsp;&nbsp;&nbsp;((UEINTX  &amp; (1 &lt;&lt; RXOUTI)) ? true : false)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d3a/a00040.html#152014341a7983c2abcbab381b4b7a06">Endpoint_IsSetupReceived</a>()&nbsp;&nbsp;&nbsp;((UEINTX  &amp; (1 &lt;&lt; RXSTPI)) ? true : false)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d3a/a00040.html#21637d437b5989c87904969d425682a3">Endpoint_ClearSetupReceived</a>()&nbsp;&nbsp;&nbsp;MACROS{ UEINTX  &amp;= ~(1 &lt;&lt; RXSTPI);                }MACROE</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d3a/a00040.html#d8473886d44a6c9de3895eb5a6748763">Endpoint_ClearSetupIN</a>()&nbsp;&nbsp;&nbsp;MACROS{ UEINTX  &amp;= ~(1 &lt;&lt; TXINI);                 }MACROE</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d3a/a00040.html#e99e315647dbf4a2464dce3a2f2659a6">Endpoint_ClearSetupOUT</a>()&nbsp;&nbsp;&nbsp;MACROS{ UEINTX  &amp;= ~(1 &lt;&lt; RXOUTI);                }MACROE</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d3a/a00040.html#ea2c8cc48a51ad578839a90f26c32f90">Endpoint_StallTransaction</a>()&nbsp;&nbsp;&nbsp;MACROS{ UECONX  |=  (1 &lt;&lt; STALLRQ);               }MACROE</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d3a/a00040.html#1178d41fbca3e0d0d6db53e14b98630b">Endpoint_ClearStall</a>()&nbsp;&nbsp;&nbsp;MACROS{ UECONX  |=  (1 &lt;&lt; STALLRQC);              }MACROE</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d3a/a00040.html#ed2450178f6eb259c80962fc695fd851">Endpoint_IsStalled</a>()&nbsp;&nbsp;&nbsp;((UECONX  &amp;   (1 &lt;&lt; STALLRQ)) ? true : false)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d3a/a00040.html#879ccfd6150a6f41699ac84282639062">Endpoint_ResetDataToggle</a>()&nbsp;&nbsp;&nbsp;MACROS{ UECONX  |=  (1 &lt;&lt; RSTDT);                 }MACROE</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d3a/a00040.html#19c5d34b4030c98d9fce888f743e42a1">Endpoint_Ignore_Byte</a>()&nbsp;&nbsp;&nbsp;Endpoint_Discard_Byte()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d3a/a00040.html#8414be12e9c82ba472c158fb454016a2">Endpoint_Ignore_Word</a>()&nbsp;&nbsp;&nbsp;Endpoint_Discard_Word()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d3a/a00040.html#6ed3ec51a6029f77a12605de7686e344">Endpoint_Ignore_DWord</a>()&nbsp;&nbsp;&nbsp;Endpoint_Discard_DWord()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d3a/a00040.html#49a81b1d7becfff50cc0dc4243181f79">Endpoint_Read_Word</a>()&nbsp;&nbsp;&nbsp;Endpoint_Read_Word_LE()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d3a/a00040.html#9968f5632bdde096bb552bb829dee176">Endpoint_Write_Word</a>(Word)&nbsp;&nbsp;&nbsp;Endpoint_Write_Word_LE(Word)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d3a/a00040.html#2e2fac018de1265df71ebd1e7dcb842a">Endpoint_Read_DWord</a>()&nbsp;&nbsp;&nbsp;Endpoint_Read_DWord_LE()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d3a/a00040.html#0e0ee281ecba3dbe5355679ba019eca0">Endpoint_Write_DWord</a>(DWord)&nbsp;&nbsp;&nbsp;Endpoint_Write_DWord_LE(DWord)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d3a/a00040.html#c1925b3f1fa68a40d948e615efca6d3d">Endpoint_Read_Stream</a>(Buffer, Length, Callback)&nbsp;&nbsp;&nbsp;Endpoint_Read_Stream_LE(Buffer, Length, Callback)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d3a/a00040.html#6180ccd2143a5589fe5b2048e2272da5">Endpoint_Write_Stream</a>(Buffer, Length, Callback)&nbsp;&nbsp;&nbsp;Endpoint_Write_Stream_LE(Buffer, Length, Callback)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d3a/a00040.html#8fd072a3ff1aa1f402b98743df9e76d5">Endpoint_Read_Control_Stream</a>(Data, Length)&nbsp;&nbsp;&nbsp;Endpoint_Read_Control_Stream_LE(Data, Length)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d3a/a00040.html#6057da3b60f4498852b1371f5b6e6dfb">Endpoint_Write_Control_Stream</a>(Data, Length)&nbsp;&nbsp;&nbsp;Endpoint_Write_Control_Stream_LE(Data, Length)</td></tr>

<tr><td colspan="2"><br><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d3a/a00040.html#a42b7eb8d1be3afadb97097bf2605740">Endpoint_WaitUntilReady_ErrorCodes_t</a> { <br>
&nbsp;&nbsp;<a class="el" href="../../db/d3a/a00040.html#a42b7eb8d1be3afadb97097bf26057405bd129a3bb182ecdcfe16549e175308a">ENDPOINT_READYWAIT_NoError</a> =  0, 
<br>
&nbsp;&nbsp;<a class="el" href="../../db/d3a/a00040.html#a42b7eb8d1be3afadb97097bf2605740c395cfec6ba73cd76fd016e746b7dc74">ENDPOINT_READYWAIT_EndpointStalled</a> =  1, 
<br>
&nbsp;&nbsp;<a class="el" href="../../db/d3a/a00040.html#a42b7eb8d1be3afadb97097bf260574039bcc8c146680a1666f2eba6dccc0152">ENDPOINT_READYWAIT_DeviceDisconnected</a> =  2, 
<br>
&nbsp;&nbsp;<a class="el" href="../../db/d3a/a00040.html#a42b7eb8d1be3afadb97097bf2605740a6da793dddcd7512d2e92599052d04b5">ENDPOINT_READYWAIT_Timeout</a> =  3
<br>
 }</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d3a/a00040.html#7f0d584afdd478f8fdf20b9daf58394b">Endpoint_Stream_RW_ErrorCodes_t</a> { <br>
&nbsp;&nbsp;<a class="el" href="../../db/d3a/a00040.html#7f0d584afdd478f8fdf20b9daf58394b02bd188672c4ae7a2eb8996e735f94fc">ENDPOINT_RWSTREAM_ERROR_NoError</a> =  0, 
<br>
&nbsp;&nbsp;<a class="el" href="../../db/d3a/a00040.html#7f0d584afdd478f8fdf20b9daf58394b0354723d3280b898d9a5d17b250af88d">ENDPOINT_RWSTREAM_ERROR_EndpointStalled</a> =  1, 
<br>
&nbsp;&nbsp;<a class="el" href="../../db/d3a/a00040.html#7f0d584afdd478f8fdf20b9daf58394bd0f9ac9f80202dcd61a25f2a72103cf3">ENDPOINT_RWSTREAM_ERROR_DeviceDisconnected</a> =  1, 
<br>
&nbsp;&nbsp;<a class="el" href="../../db/d3a/a00040.html#7f0d584afdd478f8fdf20b9daf58394b96ca2a39a0b600bd5087f647e014f7b6">ENDPOINT_RWSTREAM_ERROR_Timeout</a> =  2, 
<br>
&nbsp;&nbsp;<a class="el" href="../../db/d3a/a00040.html#7f0d584afdd478f8fdf20b9daf58394be44071abb163d65ee45fb203b70edd35">ENDPOINT_RWSTREAM_ERROR_CallbackAborted</a> =  3
<br>
 }</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d3a/a00040.html#35e8041496378a7109b95dadcf1326c1">Endpoint_ControlStream_RW_ErrorCodes_t</a> { <br>
&nbsp;&nbsp;<a class="el" href="../../db/d3a/a00040.html#35e8041496378a7109b95dadcf1326c16b2e79fd0e765c2c50ddce71da2e4d15">ENDPOINT_RWCSTREAM_ERROR_NoError</a> =  0, 
<br>
&nbsp;&nbsp;<a class="el" href="../../db/d3a/a00040.html#35e8041496378a7109b95dadcf1326c124970ab20cd221fbdb4aa6cc1dc9a4a4">ENDPOINT_RWCSTREAM_ERROR_HostAborted</a> =  1
<br>
 }</td></tr>

<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d3a/a00040.html#c3c1f4188921b180e3cf2c84589e3c23">Endpoint_Read_Byte</a> (void) ATTR_WARN_UNUSED_RESULT</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d3a/a00040.html#0ff8109e059d7148abc542d2c79e0781">Endpoint_Write_Byte</a> (const uint8_t Byte)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d3a/a00040.html#30bd85c8a02d259e6dda4f1d4d1bfc95">Endpoint_Discard_Byte</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static uint16_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d3a/a00040.html#94403bf97351658c2df36a396f382a86">Endpoint_Read_Word_LE</a> (void) ATTR_WARN_UNUSED_RESULT</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static uint16_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d3a/a00040.html#74f1de479c5714213280b079825a4457">Endpoint_Read_Word_BE</a> (void) ATTR_WARN_UNUSED_RESULT</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d3a/a00040.html#42b74e033b75075fa6d3c20b19e5ba8a">Endpoint_Write_Word_LE</a> (const uint16_t Word)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d3a/a00040.html#04bb808c3cf7c43144634383e5c82817">Endpoint_Write_Word_BE</a> (const uint16_t Word)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d3a/a00040.html#eb1cf1763043685a763979beba2a6ed7">Endpoint_Discard_Word</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d3a/a00040.html#82488a5f8e6ee9e2ffb3fb1928d48bd4">Endpoint_Read_DWord_LE</a> (void) ATTR_WARN_UNUSED_RESULT</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d3a/a00040.html#d23328f64daebf07addc4e1c6164d891">Endpoint_Read_DWord_BE</a> (void) ATTR_WARN_UNUSED_RESULT</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d3a/a00040.html#3ad2799fe37080f4cfadc3c2c18fcbc3">Endpoint_Write_DWord_LE</a> (const uint32_t DWord)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d3a/a00040.html#1015ec8ddf4e8a9df724f5f5f6e748e6">Endpoint_Write_DWord_BE</a> (const uint32_t DWord)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d3a/a00040.html#749cf12eab36e9332c63daab04f36380">Endpoint_Discard_DWord</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d3a/a00040.html#2ee0f0710d9f319a5d5d13f1b6019488">Endpoint_WaitUntilReady</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d3a/a00040.html#b419d055c2550a55c6b361188d3133a9">Endpoint_Discard_Stream</a> (uint16_t Length, uint8_t(*const Callback)(void))</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d3a/a00040.html#4ec7ef0303a01e1032c022c397995734">Endpoint_Write_Stream_LE</a> (const void *Buffer, uint16_t Length, uint8_t(*const Callback)(void)) ATTR_NON_NULL_PTR_ARG(1)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d3a/a00040.html#ae941ffeae4a40f72e989ffcd09626dd">Endpoint_Write_Stream_BE</a> (const void *Buffer, uint16_t Length, uint8_t(*const Callback)(void)) ATTR_NON_NULL_PTR_ARG(1)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d3a/a00040.html#a4338c8a0949610ff395076c836ea8f2">Endpoint_Read_Stream_LE</a> (void *Buffer, uint16_t Length, uint8_t(*const Callback)(void)) ATTR_NON_NULL_PTR_ARG(1)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d3a/a00040.html#e9ee94ea2901d447ad651ab191875857">Endpoint_Read_Stream_BE</a> (void *Buffer, uint16_t Length, uint8_t(*const Callback)(void)) ATTR_NON_NULL_PTR_ARG(1)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d3a/a00040.html#b28db1e015f6ccb22987551f0b4b7bb4">Endpoint_Write_Control_Stream_LE</a> (const void *Buffer, uint16_t Length) ATTR_NON_NULL_PTR_ARG(1)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d3a/a00040.html#e2ebee942dae1fe0fb6406583758a101">Endpoint_Write_Control_Stream_BE</a> (const void *Buffer, uint16_t Length) ATTR_NON_NULL_PTR_ARG(1)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d3a/a00040.html#e50541f5ff5f00d579ab99b09d73809d">Endpoint_Read_Control_Stream_LE</a> (void *Buffer, uint16_t Length) ATTR_NON_NULL_PTR_ARG(1)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d3a/a00040.html#be8bb452cbe61c11ffeadc352463d00d">Endpoint_Read_Control_Stream_BE</a> (void *Buffer, uint16_t Length) ATTR_NON_NULL_PTR_ARG(1)</td></tr>

<tr><td colspan="2"><br><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d3a/a00040.html#8422610dc18164a09618d82b9306c365">USB_ControlEndpointSize</a></td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Functions, macros and enums related to endpoint management when in USB Device mode. This module contains the endpoint management macros, as well as endpoint interrupt and data send/recieve functions for various datatypes. <hr><h2>Define Documentation</h2>
<a class="anchor" name="417e96e8278a9c41e846fff106ce5791"></a><!-- doxytag: member="Endpoint.h::ENDPOINT_BANK_DOUBLE" ref="417e96e8278a9c41e846fff106ce5791" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ENDPOINT_BANK_DOUBLE&nbsp;&nbsp;&nbsp;(1 &lt;&lt; EPBK0)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Mask for the bank mode selection for the <a class="el" href="../../db/d3a/a00040.html#64d277eb0702f0ffd009e201393dc1e3">Endpoint_ConfigureEndpoint()</a> macro. This indicates that the endpoint should have two banks, which requires more USB FIFO memory but results in faster transfers as one USB device (the AVR or the host) can access one bank while the other accesses the second bank. 
</div>
</div><p>
<a class="anchor" name="e4bc67200452560b253e3f01acae9373"></a><!-- doxytag: member="Endpoint.h::ENDPOINT_BANK_SINGLE" ref="e4bc67200452560b253e3f01acae9373" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ENDPOINT_BANK_SINGLE&nbsp;&nbsp;&nbsp;0          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Mask for the bank mode selection for the <a class="el" href="../../db/d3a/a00040.html#64d277eb0702f0ffd009e201393dc1e3">Endpoint_ConfigureEndpoint()</a> macro. This indicates that the endpoint should have one single bank, which requires less USB FIFO memory but results in slower transfers as only one USB device (the AVR or the host) can access the endpoint's bank at the one time. 
</div>
</div><p>
<a class="anchor" name="2036a748148fba4da9ba50c1cb59d674"></a><!-- doxytag: member="Endpoint.h::Endpoint_BytesInEndpoint" ref="2036a748148fba4da9ba50c1cb59d674" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Endpoint_BytesInEndpoint          </td>
          <td>(</td>
&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;UEBCX</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Indicates the number of bytes currently stored in the current endpoint's selected bank. 
</div>
</div><p>
<a class="anchor" name="41d8837f1719203a95724dccc90ec2ee"></a><!-- doxytag: member="Endpoint.h::Endpoint_ClearCurrentBank" ref="41d8837f1719203a95724dccc90ec2ee" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Endpoint_ClearCurrentBank          </td>
          <td>(</td>
&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;MACROS{ UEINTX  &amp;= ~(1 &lt;&lt; FIFOCON);               }MACROE</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Clears the currently selected endpoint bank, and switches to the alternate bank if the currently selected endpoint is dual-banked. When cleared, this either frees the bank up for the next packet from the host (if the endpoint is of the OUT direction) or sends the packet contents to the host (if the endpoint is of the IN direction). 
</div>
</div><p>
<a class="anchor" name="f1211509b0c301a613b8c03113563053"></a><!-- doxytag: member="Endpoint.h::Endpoint_ClearEndpointInterrupt" ref="f1211509b0c301a613b8c03113563053" args="(n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Endpoint_ClearEndpointInterrupt          </td>
          <td>(</td>
          <td class="paramtype">n&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;MACROS{ UEINT   &amp;= ~(1 &lt;&lt; n);                     }MACROE</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Clears the endpoint interrupt flag. This clears the specified endpoint number's interrupt mask in the endpoint interrupt flag register. 
</div>
</div><p>
<a class="anchor" name="d8473886d44a6c9de3895eb5a6748763"></a><!-- doxytag: member="Endpoint.h::Endpoint_ClearSetupIN" ref="d8473886d44a6c9de3895eb5a6748763" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Endpoint_ClearSetupIN          </td>
          <td>(</td>
&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;MACROS{ UEINTX  &amp;= ~(1 &lt;&lt; TXINI);                 }MACROE</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sends an IN packet to the host on the currently selected CONTROL type endpoint. 
</div>
</div><p>
<a class="anchor" name="e99e315647dbf4a2464dce3a2f2659a6"></a><!-- doxytag: member="Endpoint.h::Endpoint_ClearSetupOUT" ref="e99e315647dbf4a2464dce3a2f2659a6" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Endpoint_ClearSetupOUT          </td>
          <td>(</td>
&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;MACROS{ UEINTX  &amp;= ~(1 &lt;&lt; RXOUTI);                }MACROE</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Acknowedges an OUT packet to the host on the currently selected CONTROL type endpoint, freeing up the endpoint for the next packet. 
</div>
</div><p>
<a class="anchor" name="21637d437b5989c87904969d425682a3"></a><!-- doxytag: member="Endpoint.h::Endpoint_ClearSetupReceived" ref="21637d437b5989c87904969d425682a3" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Endpoint_ClearSetupReceived          </td>
          <td>(</td>
&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;MACROS{ UEINTX  &amp;= ~(1 &lt;&lt; RXSTPI);                }MACROE</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Clears a received SETUP packet on the currently selected CONTROL type endpoint. 
</div>
</div><p>
<a class="anchor" name="1178d41fbca3e0d0d6db53e14b98630b"></a><!-- doxytag: member="Endpoint.h::Endpoint_ClearStall" ref="1178d41fbca3e0d0d6db53e14b98630b" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Endpoint_ClearStall          </td>
          <td>(</td>
&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;MACROS{ UECONX  |=  (1 &lt;&lt; STALLRQC);              }MACROE</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Clears the stall on the currently selected endpoint. 
</div>
</div><p>
<a class="anchor" name="64d277eb0702f0ffd009e201393dc1e3"></a><!-- doxytag: member="Endpoint.h::Endpoint_ConfigureEndpoint" ref="64d277eb0702f0ffd009e201393dc1e3" args="(num, type, dir, size, banks)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Endpoint_ConfigureEndpoint          </td>
          <td>(</td>
          <td class="paramtype">num,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">dir,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">banks&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Value:</b><div class="fragment"><pre class="fragment">Endpoint_ConfigureEndpoint_P(num, size,        \
                                                       ((type &lt;&lt; EPTYPE0) | dir),                     \
                                                       banks)
</pre></div>Configures the specified endpoint number with the given endpoint type, direction, bank size and banking mode. Endpoints should be allocated in ascending order by their address in the device (i.e. endpoint 1 should be configured before endpoint 2 and so on).<p>
The endpoint type may be one of the EP_TYPE_* macros listed in <a class="el" href="../../da/d24/a00068.html">LowLevel.h</a> and the direction may be either ENDPOINT_DIR_OUT or ENDPOINT_DIR_IN.<p>
The bank size must indicate the maximum packet size that the endpoint can handle. Different endpoint numbers can handle different maximum packet sizes - refer to the chosen USB AVR's datasheet to determine the maximum bank size for each endpoint.<p>
The banking mode may be either ENDPOINT_BANK_SINGLE or ENDPOINT_BANK_DOUBLE.<p>
The success of this routine can be determined via the <a class="el" href="../../db/d3a/a00040.html#9139daacd1341586aa08015191f903a2">Endpoint_IsConfigured()</a> macro.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This routine will select the specified endpoint, and the endpoint will remain selected once the routine completes regardless of if the endpoint configuration succeeds. </dd></dl>

</div>
</div><p>
<a class="anchor" name="5735655e855a6da7ee2e48084c10d9d6"></a><!-- doxytag: member="Endpoint.h::ENDPOINT_CONTROLEP" ref="5735655e855a6da7ee2e48084c10d9d6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ENDPOINT_CONTROLEP&nbsp;&nbsp;&nbsp;0          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Endpoint address for the default control endpoint, which always resides in address 0. This is defined for convenience to give more readable code when used with the endpoint macros. 
</div>
</div><p>
<a class="anchor" name="ebe9cfe97e9292e5e8cfba9885bbd901"></a><!-- doxytag: member="Endpoint.h::ENDPOINT_CONTROLEP_DEFAULT_SIZE" ref="ebe9cfe97e9292e5e8cfba9885bbd901" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ENDPOINT_CONTROLEP_DEFAULT_SIZE&nbsp;&nbsp;&nbsp;8          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Default size of the default control endpoint's bank, until altered by the Endpoint0Size value in the device descriptor. 
</div>
</div><p>
<a class="anchor" name="be19393ecfcac9ea1ee8c6b3dc87830a"></a><!-- doxytag: member="Endpoint.h::ENDPOINT_DIR_IN" ref="be19393ecfcac9ea1ee8c6b3dc87830a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ENDPOINT_DIR_IN&nbsp;&nbsp;&nbsp;(1 &lt;&lt; EPDIR)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Endpoint data direction mask for <a class="el" href="../../db/d3a/a00040.html#64d277eb0702f0ffd009e201393dc1e3">Endpoint_ConfigureEndpoint()</a>. This indicates that the endpoint should be initialized in the IN direction - i.e. data flows from device to host. 
</div>
</div><p>
<a class="anchor" name="b011e2ee1e9f55b60cda3dbc79b95961"></a><!-- doxytag: member="Endpoint.h::ENDPOINT_DIR_OUT" ref="b011e2ee1e9f55b60cda3dbc79b95961" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ENDPOINT_DIR_OUT&nbsp;&nbsp;&nbsp;0          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Endpoint data direction mask for <a class="el" href="../../db/d3a/a00040.html#64d277eb0702f0ffd009e201393dc1e3">Endpoint_ConfigureEndpoint()</a>. This indicates that the endpoint should be initialized in the OUT direction - i.e. data flows from host to device. 
</div>
</div><p>
<a class="anchor" name="fc1ca931a94f9ae403985dfe6fb491e5"></a><!-- doxytag: member="Endpoint.h::Endpoint_DisableEndpoint" ref="fc1ca931a94f9ae403985dfe6fb491e5" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Endpoint_DisableEndpoint          </td>
          <td>(</td>
&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;MACROS{ UECONX  &amp;= ~(1 &lt;&lt; EPEN);                   }MACROE</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Disables the currently selected endpoint so that data cannot be sent and received through it to and from a host. 
</div>
</div><p>
<a class="anchor" name="c3147c22cb57edf6e96e8106f6752696"></a><!-- doxytag: member="Endpoint.h::Endpoint_EnableEndpoint" ref="c3147c22cb57edf6e96e8106f6752696" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Endpoint_EnableEndpoint          </td>
          <td>(</td>
&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;MACROS{ UECONX  |=  (1 &lt;&lt; EPEN);                   }MACROE</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Enables the currently selected endpoint so that data can be sent and received through it to and from a host.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Endpoints must first be configured properly rather than just being enabled via the <a class="el" href="../../db/d3a/a00040.html#64d277eb0702f0ffd009e201393dc1e3">Endpoint_ConfigureEndpoint()</a> macro, which calls <a class="el" href="../../db/d3a/a00040.html#c3147c22cb57edf6e96e8106f6752696">Endpoint_EnableEndpoint()</a> automatically. </dd></dl>

</div>
</div><p>
<a class="anchor" name="6ee88e6fd992e2a064923871980b493d"></a><!-- doxytag: member="Endpoint.h::ENDPOINT_EPNUM_MASK" ref="6ee88e6fd992e2a064923871980b493d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ENDPOINT_EPNUM_MASK&nbsp;&nbsp;&nbsp;0b111          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Endpoint number mask, for masking against endpoint addresses to retrieve the endpoint's numerical address in the device. 
</div>
</div><p>
<a class="anchor" name="afb7a906223f76d344a8ad05bf066f4c"></a><!-- doxytag: member="Endpoint.h::ENDPOINT_EPSIZE_MASK" ref="afb7a906223f76d344a8ad05bf066f4c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ENDPOINT_EPSIZE_MASK&nbsp;&nbsp;&nbsp;0x7FF          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Endpoint bank size mask, for masking against endpoint addresses to retrieve the endpoint's bank size in the device. 
</div>
</div><p>
<a class="anchor" name="4b624a8716463aac308149c38bb6323f"></a><!-- doxytag: member="Endpoint.h::Endpoint_GetCurrentEndpoint" ref="4b624a8716463aac308149c38bb6323f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Endpoint_GetCurrentEndpoint          </td>
          <td>(</td>
&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;(UENUM   &amp;   ENDPOINT_EPNUM_MASK)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the endpoint address of the currently selected endpoint. This is typically used to save the currently selected endpoint number so that it can be restored after another endpoint has been manipulated. 
</div>
</div><p>
<a class="anchor" name="6d7af6c9eb867d04de9fc7c0e7be1c04"></a><!-- doxytag: member="Endpoint.h::Endpoint_GetEndpointInterrupts" ref="6d7af6c9eb867d04de9fc7c0e7be1c04" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Endpoint_GetEndpointInterrupts          </td>
          <td>(</td>
&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;UEINT</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a mask indicating which INTERRUPT type endpoints have interrupted - i.e. their interrupt duration has elapsed. Which endpoints have interrupted can be determined by masking the return value against (1 &lt;&lt; {Endpoint Number}). 
</div>
</div><p>
<a class="anchor" name="e2347441f26d71d15b96f084a6dcf747"></a><!-- doxytag: member="Endpoint.h::Endpoint_HasEndpointInterrupted" ref="e2347441f26d71d15b96f084a6dcf747" args="(n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Endpoint_HasEndpointInterrupted          </td>
          <td>(</td>
          <td class="paramtype">n&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;((UEINT   &amp;   (1 &lt;&lt; n)) ? true : false)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if the specified endpoint number has interrupted (valid only for INTERRUPT type endpoints), false otherwise. 
</div>
</div><p>
<a class="anchor" name="19c5d34b4030c98d9fce888f743e42a1"></a><!-- doxytag: member="Endpoint.h::Endpoint_Ignore_Byte" ref="19c5d34b4030c98d9fce888f743e42a1" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Endpoint_Ignore_Byte          </td>
          <td>(</td>
&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;Endpoint_Discard_Byte()</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Alias for <a class="el" href="../../db/d3a/a00040.html#30bd85c8a02d259e6dda4f1d4d1bfc95">Endpoint_Discard_Byte()</a>. 
</div>
</div><p>
<a class="anchor" name="6ed3ec51a6029f77a12605de7686e344"></a><!-- doxytag: member="Endpoint.h::Endpoint_Ignore_DWord" ref="6ed3ec51a6029f77a12605de7686e344" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Endpoint_Ignore_DWord          </td>
          <td>(</td>
&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;Endpoint_Discard_DWord()</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Alias for <a class="el" href="../../db/d3a/a00040.html#749cf12eab36e9332c63daab04f36380">Endpoint_Discard_DWord()</a>. 
</div>
</div><p>
<a class="anchor" name="8414be12e9c82ba472c158fb454016a2"></a><!-- doxytag: member="Endpoint.h::Endpoint_Ignore_Word" ref="8414be12e9c82ba472c158fb454016a2" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Endpoint_Ignore_Word          </td>
          <td>(</td>
&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;Endpoint_Discard_Word()</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Alias for <a class="el" href="../../db/d3a/a00040.html#eb1cf1763043685a763979beba2a6ed7">Endpoint_Discard_Word()</a>. 
</div>
</div><p>
<a class="anchor" name="00a6a6e9368105863364e410d1fcecb2"></a><!-- doxytag: member="Endpoint.h::ENDPOINT_INT_IN" ref="00a6a6e9368105863364e410d1fcecb2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ENDPOINT_INT_IN&nbsp;&nbsp;&nbsp;UEIENX, (1 &lt;&lt; TXINE) , UEINTX, (1 &lt;&lt; TXINI)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Interrupt definition for the endpoint IN interrupt (for INTERRUPT type endpoints). Should be used with the USB_INT_* macros located in <a class="el" href="../../db/ddf/a00088.html">USBInterrupt.h</a>.<p>
This interrupt will fire if enabled on an INTERRUPT type endpoint if a the endpoint interrupt period has elapsed and the endpoint is ready for a new packet to be written to its FIFO buffer (if required). 
</div>
</div><p>
<a class="anchor" name="c48adc496b7ab8a89a50cb27eff25bee"></a><!-- doxytag: member="Endpoint.h::ENDPOINT_INT_OUT" ref="c48adc496b7ab8a89a50cb27eff25bee" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ENDPOINT_INT_OUT&nbsp;&nbsp;&nbsp;UEIENX, (1 &lt;&lt; RXOUTE), UEINTX, (1 &lt;&lt; RXOUTI)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Interrupt definition for the endpoint OUT interrupt (for INTERRUPT type endpoints). Should be used with the USB_INT_* macros located in <a class="el" href="../../db/ddf/a00088.html">USBInterrupt.h</a>.<p>
This interrupt will fire if enabled on an INTERRUPT type endpoint if a the endpoint interrupt period has elapsed and the endpoint is ready for a packet from the host to be read from its FIFO buffer (if received). 
</div>
</div><p>
<a class="anchor" name="2ba13d7ad8aaa339d0ca1b357bf2fabc"></a><!-- doxytag: member="Endpoint.h::ENDPOINT_INT_SETUP" ref="2ba13d7ad8aaa339d0ca1b357bf2fabc" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ENDPOINT_INT_SETUP&nbsp;&nbsp;&nbsp;UEIENX, (1 &lt;&lt; RXSTPE), UEINTX, (1 &lt;&lt; RXSTPI)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Interrupt definition for the endpoint SETUP interrupt (for CONTROL type endpoints). Should be used with the USB_INT_* macros located in <a class="el" href="../../db/ddf/a00088.html">USBInterrupt.h</a>.<p>
This interrupt will fire if enabled on a CONTROL type endpoint if a new control packet is received from the host. 
</div>
</div><p>
<a class="anchor" name="9139daacd1341586aa08015191f903a2"></a><!-- doxytag: member="Endpoint.h::Endpoint_IsConfigured" ref="9139daacd1341586aa08015191f903a2" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Endpoint_IsConfigured          </td>
          <td>(</td>
&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;((UESTA0X &amp; (1 &lt;&lt; CFGOK)) ? true : false)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if the currently selected endpoint is configured, false otherwise. 
</div>
</div><p>
<a class="anchor" name="368f9de07439857a318a949edbcd9c79"></a><!-- doxytag: member="Endpoint.h::Endpoint_IsEnabled" ref="368f9de07439857a318a949edbcd9c79" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Endpoint_IsEnabled          </td>
          <td>(</td>
&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;((UECONX  &amp;   (1 &lt;&lt; EPEN)) ? true : false)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if the currently selected endpoint is enabled, false otherwise. 
</div>
</div><p>
<a class="anchor" name="2ed21d9682bd7e5f602923f94ac54333"></a><!-- doxytag: member="Endpoint.h::Endpoint_IsSetupINReady" ref="2ed21d9682bd7e5f602923f94ac54333" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Endpoint_IsSetupINReady          </td>
          <td>(</td>
&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;((UEINTX  &amp; (1 &lt;&lt; TXINI))  ? true : false)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if the current CONTROL type endpoint is ready for an IN packet, false otherwise. 
</div>
</div><p>
<a class="anchor" name="ce5510430ebc0cc8f891acdb1c2a9be9"></a><!-- doxytag: member="Endpoint.h::Endpoint_IsSetupOUTReceived" ref="ce5510430ebc0cc8f891acdb1c2a9be9" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Endpoint_IsSetupOUTReceived          </td>
          <td>(</td>
&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;((UEINTX  &amp; (1 &lt;&lt; RXOUTI)) ? true : false)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if the current CONTROL type endpoint is ready for an OUT packet, false otherwise. 
</div>
</div><p>
<a class="anchor" name="152014341a7983c2abcbab381b4b7a06"></a><!-- doxytag: member="Endpoint.h::Endpoint_IsSetupReceived" ref="152014341a7983c2abcbab381b4b7a06" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Endpoint_IsSetupReceived          </td>
          <td>(</td>
&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;((UEINTX  &amp; (1 &lt;&lt; RXSTPI)) ? true : false)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if the current CONTROL type endpoint is ready for a SETUP packet, false otherwise. 
</div>
</div><p>
<a class="anchor" name="ed2450178f6eb259c80962fc695fd851"></a><!-- doxytag: member="Endpoint.h::Endpoint_IsStalled" ref="ed2450178f6eb259c80962fc695fd851" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Endpoint_IsStalled          </td>
          <td>(</td>
&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;((UECONX  &amp;   (1 &lt;&lt; STALLRQ)) ? true : false)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if the currently selected endpoint is stalled, false othewise. 
</div>
</div><p>
<a class="anchor" name="3e245962bd3c397a47d8cfde79d6c2a2"></a><!-- doxytag: member="Endpoint.h::ENDPOINT_MAX_ENDPOINTS" ref="3e245962bd3c397a47d8cfde79d6c2a2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ENDPOINT_MAX_ENDPOINTS&nbsp;&nbsp;&nbsp;7          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Total number of endpoints (including the default control endpoint at address 0) which may be used in the device. Different USB AVR models support different amounts of endpoints, this value reflects the maximum number of endpoints for the currently selected AVR model. 
</div>
</div><p>
<a class="anchor" name="0c326f3e68fd43f00c9f26b51b71c274"></a><!-- doxytag: member="Endpoint.h::ENDPOINT_MAX_SIZE" ref="0c326f3e68fd43f00c9f26b51b71c274" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ENDPOINT_MAX_SIZE&nbsp;&nbsp;&nbsp;256          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Size in bytes of the largest endpoint bank size possible in the device. Not all banks on each AVR model supports the largest bank size possible on the device; different endpoint numbers support different maximum bank sizes. This value reflects the largest possible bank of any endpoint on the currently selected USB AVR model. 
</div>
</div><p>
<a class="anchor" name="8fd072a3ff1aa1f402b98743df9e76d5"></a><!-- doxytag: member="Endpoint.h::Endpoint_Read_Control_Stream" ref="8fd072a3ff1aa1f402b98743df9e76d5" args="(Data, Length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Endpoint_Read_Control_Stream          </td>
          <td>(</td>
          <td class="paramtype">Data,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Length&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;Endpoint_Read_Control_Stream_LE(Data, Length)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Alias for <a class="el" href="../../db/d3a/a00040.html#e50541f5ff5f00d579ab99b09d73809d">Endpoint_Read_Control_Stream_LE()</a>. By default USB transfers use little endian format, thus the command with no endianness specifier indicates little endian mode. 
</div>
</div><p>
<a class="anchor" name="2e2fac018de1265df71ebd1e7dcb842a"></a><!-- doxytag: member="Endpoint.h::Endpoint_Read_DWord" ref="2e2fac018de1265df71ebd1e7dcb842a" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Endpoint_Read_DWord          </td>
          <td>(</td>
&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;Endpoint_Read_DWord_LE()</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Alias for <a class="el" href="../../db/d3a/a00040.html#82488a5f8e6ee9e2ffb3fb1928d48bd4">Endpoint_Read_DWord_LE()</a>. By default USB transfers use little endian format, thus the command with no endianness specifier indicates little endian mode. 
</div>
</div><p>
<a class="anchor" name="c1925b3f1fa68a40d948e615efca6d3d"></a><!-- doxytag: member="Endpoint.h::Endpoint_Read_Stream" ref="c1925b3f1fa68a40d948e615efca6d3d" args="(Buffer, Length, Callback)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Endpoint_Read_Stream          </td>
          <td>(</td>
          <td class="paramtype">Buffer,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Length,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Callback&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;Endpoint_Read_Stream_LE(Buffer, Length, Callback)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Alias for <a class="el" href="../../db/d3a/a00040.html#a4338c8a0949610ff395076c836ea8f2">Endpoint_Read_Stream_LE()</a>. By default USB transfers use little endian format, thus the command with no endianness specifier indicates little endian mode. 
</div>
</div><p>
<a class="anchor" name="49a81b1d7becfff50cc0dc4243181f79"></a><!-- doxytag: member="Endpoint.h::Endpoint_Read_Word" ref="49a81b1d7becfff50cc0dc4243181f79" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Endpoint_Read_Word          </td>
          <td>(</td>
&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;Endpoint_Read_Word_LE()</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Alias for <a class="el" href="../../db/d3a/a00040.html#94403bf97351658c2df36a396f382a86">Endpoint_Read_Word_LE()</a>. By default USB transfers use little endian format, thus the command with no endianness specifier indicates little endian mode. 
</div>
</div><p>
<a class="anchor" name="7d816c2bf5bb331ebbf6f2857f563e21"></a><!-- doxytag: member="Endpoint.h::Endpoint_ReadWriteAllowed" ref="7d816c2bf5bb331ebbf6f2857f563e21" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Endpoint_ReadWriteAllowed          </td>
          <td>(</td>
&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;((UEINTX  &amp; (1 &lt;&lt; RWAL)) ? true : false)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if the currently selected endpoint may be read from (if data is waiting in the endpoint bank and the endpoint is an OUT direction, or if the bank is not yet full if the endpoint is an IN direction). This function will return false if an error has occured in the endpoint, or if the endpoint is an OUT direction and no packet has been received, or if the endpoint is an IN direction and the endpoint bank is full. 
</div>
</div><p>
<a class="anchor" name="879ccfd6150a6f41699ac84282639062"></a><!-- doxytag: member="Endpoint.h::Endpoint_ResetDataToggle" ref="879ccfd6150a6f41699ac84282639062" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Endpoint_ResetDataToggle          </td>
          <td>(</td>
&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;MACROS{ UECONX  |=  (1 &lt;&lt; RSTDT);                 }MACROE</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Resets the data toggle of the currently selected endpoint. 
</div>
</div><p>
<a class="anchor" name="1648a4932e17380fa8dde89f5d952911"></a><!-- doxytag: member="Endpoint.h::Endpoint_ResetFIFO" ref="1648a4932e17380fa8dde89f5d952911" args="(epnum)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Endpoint_ResetFIFO          </td>
          <td>(</td>
          <td class="paramtype">epnum&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;MACROS{ UERST    =  (1 &lt;&lt; epnum); UERST = 0;       }MACROE</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Resets the endpoint bank FIFO. This clears all the endpoint banks and resets the USB controller's In and Out pointers to the bank's contents. 
</div>
</div><p>
<a class="anchor" name="9bbfbc4d395831ee7d9bd6316ef603ce"></a><!-- doxytag: member="Endpoint.h::Endpoint_SelectEndpoint" ref="9bbfbc4d395831ee7d9bd6316ef603ce" args="(epnum)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Endpoint_SelectEndpoint          </td>
          <td>(</td>
          <td class="paramtype">epnum&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;MACROS{ UENUM    =  epnum;                         }MACROE</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Selects the given endpoint number. If the address from the device descriptors is used, the value should be masked with the ENDPOINT_EPNUM_MASK constant to extract only the endpoint number (and discarding the endpoint direction bit).<p>
Any endpoint operations which do not require the endpoint number to be indicated will operate on the currently selected endpoint. 
</div>
</div><p>
<a class="anchor" name="ea2c8cc48a51ad578839a90f26c32f90"></a><!-- doxytag: member="Endpoint.h::Endpoint_StallTransaction" ref="ea2c8cc48a51ad578839a90f26c32f90" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Endpoint_StallTransaction          </td>
          <td>(</td>
&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;MACROS{ UECONX  |=  (1 &lt;&lt; STALLRQ);               }MACROE</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Stalls the current endpoint, indicating to the host that a logical problem occured with the indicated endpoint and that the current transfer sequence should be aborted. This provides a way for devices to indicate invalid commands to the host so that the current transfer can be aborted and the host can begin its own recovery seqeuence.<p>
The currently selected endpoint remains stalled until either the <a class="el" href="../../db/d3a/a00040.html#1178d41fbca3e0d0d6db53e14b98630b">Endpoint_ClearStall()</a> macro is called, or the host issues a CLEAR FEATURE request to the device for the currently selected endpoint. 
</div>
</div><p>
<a class="anchor" name="6057da3b60f4498852b1371f5b6e6dfb"></a><!-- doxytag: member="Endpoint.h::Endpoint_Write_Control_Stream" ref="6057da3b60f4498852b1371f5b6e6dfb" args="(Data, Length)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Endpoint_Write_Control_Stream          </td>
          <td>(</td>
          <td class="paramtype">Data,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Length&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;Endpoint_Write_Control_Stream_LE(Data, Length)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Alias for <a class="el" href="../../db/d3a/a00040.html#b28db1e015f6ccb22987551f0b4b7bb4">Endpoint_Write_Control_Stream_LE()</a>. By default USB transfers use little endian format, thus the command with no endianness specifier indicates little endian mode. 
</div>
</div><p>
<a class="anchor" name="0e0ee281ecba3dbe5355679ba019eca0"></a><!-- doxytag: member="Endpoint.h::Endpoint_Write_DWord" ref="0e0ee281ecba3dbe5355679ba019eca0" args="(DWord)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Endpoint_Write_DWord          </td>
          <td>(</td>
          <td class="paramtype">DWord&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;Endpoint_Write_DWord_LE(DWord)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Alias for <a class="el" href="../../db/d3a/a00040.html#3ad2799fe37080f4cfadc3c2c18fcbc3">Endpoint_Write_DWord_LE()</a>. By default USB transfers use little endian format, thus the command with no endianness specifier indicates little endian mode. 
</div>
</div><p>
<a class="anchor" name="6180ccd2143a5589fe5b2048e2272da5"></a><!-- doxytag: member="Endpoint.h::Endpoint_Write_Stream" ref="6180ccd2143a5589fe5b2048e2272da5" args="(Buffer, Length, Callback)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Endpoint_Write_Stream          </td>
          <td>(</td>
          <td class="paramtype">Buffer,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Length,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Callback&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;Endpoint_Write_Stream_LE(Buffer, Length, Callback)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Alias for <a class="el" href="../../db/d3a/a00040.html#4ec7ef0303a01e1032c022c397995734">Endpoint_Write_Stream_LE()</a>. By default USB transfers use little endian format, thus the command with no endianness specifier indicates little endian mode. 
</div>
</div><p>
<a class="anchor" name="9968f5632bdde096bb552bb829dee176"></a><!-- doxytag: member="Endpoint.h::Endpoint_Write_Word" ref="9968f5632bdde096bb552bb829dee176" args="(Word)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Endpoint_Write_Word          </td>
          <td>(</td>
          <td class="paramtype">Word&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;Endpoint_Write_Word_LE(Word)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Alias for <a class="el" href="../../db/d3a/a00040.html#42b74e033b75075fa6d3c20b19e5ba8a">Endpoint_Write_Word_LE()</a>. By default USB transfers use little endian format, thus the command with no endianness specifier indicates little endian mode. 
</div>
</div><p>
<hr><h2>Enumeration Type Documentation</h2>
<a class="anchor" name="35e8041496378a7109b95dadcf1326c1"></a><!-- doxytag: member="Endpoint.h::Endpoint_ControlStream_RW_ErrorCodes_t" ref="35e8041496378a7109b95dadcf1326c1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="../../db/d3a/a00040.html#35e8041496378a7109b95dadcf1326c1">Endpoint_ControlStream_RW_ErrorCodes_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Enum for the possible error return codes of the Endpoint_*_Control_Stream_* functions. <dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="35e8041496378a7109b95dadcf1326c16b2e79fd0e765c2c50ddce71da2e4d15"></a><!-- doxytag: member="ENDPOINT_RWCSTREAM_ERROR_NoError" ref="35e8041496378a7109b95dadcf1326c16b2e79fd0e765c2c50ddce71da2e4d15" args="" -->ENDPOINT_RWCSTREAM_ERROR_NoError</em>&nbsp;</td><td>
Command completed successfully, no error. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="35e8041496378a7109b95dadcf1326c124970ab20cd221fbdb4aa6cc1dc9a4a4"></a><!-- doxytag: member="ENDPOINT_RWCSTREAM_ERROR_HostAborted" ref="35e8041496378a7109b95dadcf1326c124970ab20cd221fbdb4aa6cc1dc9a4a4" args="" -->ENDPOINT_RWCSTREAM_ERROR_HostAborted</em>&nbsp;</td><td>
The aborted the transfer prematurely. </td></tr>
</table>
</dl>

</div>
</div><p>
<a class="anchor" name="7f0d584afdd478f8fdf20b9daf58394b"></a><!-- doxytag: member="Endpoint.h::Endpoint_Stream_RW_ErrorCodes_t" ref="7f0d584afdd478f8fdf20b9daf58394b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="../../db/d3a/a00040.html#7f0d584afdd478f8fdf20b9daf58394b">Endpoint_Stream_RW_ErrorCodes_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Enum for the possible error return codes of the Endpoint_*_Stream_* functions. <dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="7f0d584afdd478f8fdf20b9daf58394b02bd188672c4ae7a2eb8996e735f94fc"></a><!-- doxytag: member="ENDPOINT_RWSTREAM_ERROR_NoError" ref="7f0d584afdd478f8fdf20b9daf58394b02bd188672c4ae7a2eb8996e735f94fc" args="" -->ENDPOINT_RWSTREAM_ERROR_NoError</em>&nbsp;</td><td>
Command completed successfully, no error. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="7f0d584afdd478f8fdf20b9daf58394b0354723d3280b898d9a5d17b250af88d"></a><!-- doxytag: member="ENDPOINT_RWSTREAM_ERROR_EndpointStalled" ref="7f0d584afdd478f8fdf20b9daf58394b0354723d3280b898d9a5d17b250af88d" args="" -->ENDPOINT_RWSTREAM_ERROR_EndpointStalled</em>&nbsp;</td><td>
The endpoint was stalled during the stream transfer by the host or device. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="7f0d584afdd478f8fdf20b9daf58394bd0f9ac9f80202dcd61a25f2a72103cf3"></a><!-- doxytag: member="ENDPOINT_RWSTREAM_ERROR_DeviceDisconnected" ref="7f0d584afdd478f8fdf20b9daf58394bd0f9ac9f80202dcd61a25f2a72103cf3" args="" -->ENDPOINT_RWSTREAM_ERROR_DeviceDisconnected</em>&nbsp;</td><td>
Device was disconnected from the host during the transfer. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="7f0d584afdd478f8fdf20b9daf58394b96ca2a39a0b600bd5087f647e014f7b6"></a><!-- doxytag: member="ENDPOINT_RWSTREAM_ERROR_Timeout" ref="7f0d584afdd478f8fdf20b9daf58394b96ca2a39a0b600bd5087f647e014f7b6" args="" -->ENDPOINT_RWSTREAM_ERROR_Timeout</em>&nbsp;</td><td>
The host failed to accept or send the next packet within the software timeout period set by the USB_STREAM_TIMEOUT_MS macro. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="7f0d584afdd478f8fdf20b9daf58394be44071abb163d65ee45fb203b70edd35"></a><!-- doxytag: member="ENDPOINT_RWSTREAM_ERROR_CallbackAborted" ref="7f0d584afdd478f8fdf20b9daf58394be44071abb163d65ee45fb203b70edd35" args="" -->ENDPOINT_RWSTREAM_ERROR_CallbackAborted</em>&nbsp;</td><td>
Indicates that the stream's callback function aborted the transfer early. </td></tr>
</table>
</dl>

</div>
</div><p>
<a class="anchor" name="a42b7eb8d1be3afadb97097bf2605740"></a><!-- doxytag: member="Endpoint.h::Endpoint_WaitUntilReady_ErrorCodes_t" ref="a42b7eb8d1be3afadb97097bf2605740" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="../../db/d3a/a00040.html#a42b7eb8d1be3afadb97097bf2605740">Endpoint_WaitUntilReady_ErrorCodes_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Enum for the possible error return codes of the Endpoint_WaitUntilReady function <dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="a42b7eb8d1be3afadb97097bf26057405bd129a3bb182ecdcfe16549e175308a"></a><!-- doxytag: member="ENDPOINT_READYWAIT_NoError" ref="a42b7eb8d1be3afadb97097bf26057405bd129a3bb182ecdcfe16549e175308a" args="" -->ENDPOINT_READYWAIT_NoError</em>&nbsp;</td><td>
Endpoint is ready for next packet, no error. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="a42b7eb8d1be3afadb97097bf2605740c395cfec6ba73cd76fd016e746b7dc74"></a><!-- doxytag: member="ENDPOINT_READYWAIT_EndpointStalled" ref="a42b7eb8d1be3afadb97097bf2605740c395cfec6ba73cd76fd016e746b7dc74" args="" -->ENDPOINT_READYWAIT_EndpointStalled</em>&nbsp;</td><td>
The endpoint was stalled during the stream transfer by the host or device. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="a42b7eb8d1be3afadb97097bf260574039bcc8c146680a1666f2eba6dccc0152"></a><!-- doxytag: member="ENDPOINT_READYWAIT_DeviceDisconnected" ref="a42b7eb8d1be3afadb97097bf260574039bcc8c146680a1666f2eba6dccc0152" args="" -->ENDPOINT_READYWAIT_DeviceDisconnected</em>&nbsp;</td><td>
Device was disconnected from the host while waiting for the endpoint to become ready. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="a42b7eb8d1be3afadb97097bf2605740a6da793dddcd7512d2e92599052d04b5"></a><!-- doxytag: member="ENDPOINT_READYWAIT_Timeout" ref="a42b7eb8d1be3afadb97097bf2605740a6da793dddcd7512d2e92599052d04b5" args="" -->ENDPOINT_READYWAIT_Timeout</em>&nbsp;</td><td>
The host failed to accept or send the next packet within the software timeout period set by the USB_STREAM_TIMEOUT_MS macro. </td></tr>
</table>
</dl>

</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="30bd85c8a02d259e6dda4f1d4d1bfc95"></a><!-- doxytag: member="Endpoint.h::Endpoint_Discard_Byte" ref="30bd85c8a02d259e6dda4f1d4d1bfc95" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void Endpoint_Discard_Byte           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Discards one byte from the currently selected endpoint's bank, for OUT direction endpoints. 
</div>
</div><p>
<a class="anchor" name="749cf12eab36e9332c63daab04f36380"></a><!-- doxytag: member="Endpoint.h::Endpoint_Discard_DWord" ref="749cf12eab36e9332c63daab04f36380" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void Endpoint_Discard_DWord           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Discards four bytes from the currently selected endpoint's bank, for OUT direction endpoints. 
</div>
</div><p>
<a class="anchor" name="b419d055c2550a55c6b361188d3133a9"></a><!-- doxytag: member="Endpoint.h::Endpoint_Discard_Stream" ref="b419d055c2550a55c6b361188d3133a9" args="(uint16_t Length, uint8_t(*const Callback)(void))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t Endpoint_Discard_Stream           </td>
          <td>(</td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>Length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t(*)(void)&nbsp;</td>
          <td class="paramname"> <em>Callback</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reads and discards the given number of bytes from the endpoint from the given buffer, discarding fully read packets from the host as needed. The last packet is not automatically discarded once the remaining bytes has been read; the user is responsible for manually discarding the last packet from the host via the <a class="el" href="../../db/d3a/a00040.html#41d8837f1719203a95724dccc90ec2ee">Endpoint_ClearCurrentBank()</a> macro. Between each USB packet, the given stream callback function is executed repeatedly until the next packet is ready, allowing for early aborts of stream transfers.<p>
The callback routine should be created using the <a class="el" href="../../d4/d63/a00082.html#d6e3a0d3480d20e11549313a8d26075c">STREAM_CALLBACK()</a> macro. If the token NO_STREAM_CALLBACKS is passed via the -D option to the compiler, stream callbacks are disabled and this function has the Callback parameter ommitted.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This routine should not be used on CONTROL type endpoints.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Length</em>&nbsp;</td><td>Number of bytes to send via the currently selected endpoint. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Callback</em>&nbsp;</td><td>Name of a callback routine to call between sucessive USB packet transfers, NULL if no callback</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A value from the Endpoint_Stream_RW_ErrorCodes_t enum. </dd></dl>

</div>
</div><p>
<a class="anchor" name="eb1cf1763043685a763979beba2a6ed7"></a><!-- doxytag: member="Endpoint.h::Endpoint_Discard_Word" ref="eb1cf1763043685a763979beba2a6ed7" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void Endpoint_Discard_Word           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Discards two bytes from the currently selected endpoint's bank, for OUT direction endpoints. 
</div>
</div><p>
<a class="anchor" name="c3c1f4188921b180e3cf2c84589e3c23"></a><!-- doxytag: member="Endpoint.h::Endpoint_Read_Byte" ref="c3c1f4188921b180e3cf2c84589e3c23" args="(void) ATTR_WARN_UNUSED_RESULT" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static uint8_t Endpoint_Read_Byte           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reads one byte from the currently selected endpoint's bank, for OUT direction endpoints. 
</div>
</div><p>
<a class="anchor" name="be8bb452cbe61c11ffeadc352463d00d"></a><!-- doxytag: member="Endpoint.h::Endpoint_Read_Control_Stream_BE" ref="be8bb452cbe61c11ffeadc352463d00d" args="(void *Buffer, uint16_t Length) ATTR_NON_NULL_PTR_ARG(1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t Endpoint_Read_Control_Stream_BE           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>Buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>Length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reads the given number of bytes from the CONTROL endpoint from the given buffer in big endian, discarding fully read packets from the host as needed. The device IN acknowedgement is not automatically sent after success or failure states; the user is responsible for manually sending the setup IN to finalize the transfer via the <a class="el" href="../../db/d3a/a00040.html#d8473886d44a6c9de3895eb5a6748763">Endpoint_ClearSetupIN()</a> macro.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This routine should only be used on CONTROL type endpoints.</dd></dl>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>Unlike the standard stream read/write commands, the control stream commands cannot be chained together; i.e. the entire stream data must be read or written at the one time.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Buffer</em>&nbsp;</td><td>Pointer to the destination data buffer to write to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Length</em>&nbsp;</td><td>Number of bytes to send via the currently selected endpoint.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A value from the Endpoint_ControlStream_RW_ErrorCodes_t enum. </dd></dl>

</div>
</div><p>
<a class="anchor" name="e50541f5ff5f00d579ab99b09d73809d"></a><!-- doxytag: member="Endpoint.h::Endpoint_Read_Control_Stream_LE" ref="e50541f5ff5f00d579ab99b09d73809d" args="(void *Buffer, uint16_t Length) ATTR_NON_NULL_PTR_ARG(1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t Endpoint_Read_Control_Stream_LE           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>Buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>Length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reads the given number of bytes from the CONTROL endpoint from the given buffer in little endian, discarding fully read packets from the host as needed. The device IN acknowedgement is not automatically sent after success or failure states; the user is responsible for manually sending the setup IN to finalize the transfer via the <a class="el" href="../../db/d3a/a00040.html#d8473886d44a6c9de3895eb5a6748763">Endpoint_ClearSetupIN()</a> macro.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This routine should only be used on CONTROL type endpoints.</dd></dl>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>Unlike the standard stream read/write commands, the control stream commands cannot be chained together; i.e. the entire stream data must be read or written at the one time.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Buffer</em>&nbsp;</td><td>Pointer to the destination data buffer to write to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Length</em>&nbsp;</td><td>Number of bytes to send via the currently selected endpoint.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A value from the Endpoint_ControlStream_RW_ErrorCodes_t enum. </dd></dl>

</div>
</div><p>
<a class="anchor" name="d23328f64daebf07addc4e1c6164d891"></a><!-- doxytag: member="Endpoint.h::Endpoint_Read_DWord_BE" ref="d23328f64daebf07addc4e1c6164d891" args="(void) ATTR_WARN_UNUSED_RESULT" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t Endpoint_Read_DWord_BE           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reads four bytes from the currently selected endpoint's bank in big endian format, for OUT direction endpoints. 
</div>
</div><p>
<a class="anchor" name="82488a5f8e6ee9e2ffb3fb1928d48bd4"></a><!-- doxytag: member="Endpoint.h::Endpoint_Read_DWord_LE" ref="82488a5f8e6ee9e2ffb3fb1928d48bd4" args="(void) ATTR_WARN_UNUSED_RESULT" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t Endpoint_Read_DWord_LE           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reads four bytes from the currently selected endpoint's bank in little endian format, for OUT direction endpoints. 
</div>
</div><p>
<a class="anchor" name="e9ee94ea2901d447ad651ab191875857"></a><!-- doxytag: member="Endpoint.h::Endpoint_Read_Stream_BE" ref="e9ee94ea2901d447ad651ab191875857" args="(void *Buffer, uint16_t Length, uint8_t(*const Callback)(void)) ATTR_NON_NULL_PTR_ARG(1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t Endpoint_Read_Stream_BE           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>Buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>Length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t(*)(void)&nbsp;</td>
          <td class="paramname"> <em>Callback</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reads the given number of bytes from the endpoint from the given buffer in big endian, discarding fully read packets from the host as needed. The last packet is not automatically discarded once the remaining bytes has been read; the user is responsible for manually discarding the last packet from the host via the <a class="el" href="../../db/d3a/a00040.html#41d8837f1719203a95724dccc90ec2ee">Endpoint_ClearCurrentBank()</a> macro. Between each USB packet, the given stream callback function is executed repeatedly until the endpoint is ready to accept the next packet, allowing for early aborts of stream transfers.<p>
The callback routine should be created using the <a class="el" href="../../d4/d63/a00082.html#d6e3a0d3480d20e11549313a8d26075c">STREAM_CALLBACK()</a> macro. If the token NO_STREAM_CALLBACKS is passed via the -D option to the compiler, stream callbacks are disabled and this function has the Callback parameter ommitted.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This routine should not be used on CONTROL type endpoints.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Buffer</em>&nbsp;</td><td>Pointer to the destination data buffer to write to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Length</em>&nbsp;</td><td>Number of bytes to send via the currently selected endpoint. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Callback</em>&nbsp;</td><td>Name of a callback routine to call between sucessive USB packet transfers, NULL if no callback</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A value from the Endpoint_Stream_RW_ErrorCodes_t enum. </dd></dl>

</div>
</div><p>
<a class="anchor" name="a4338c8a0949610ff395076c836ea8f2"></a><!-- doxytag: member="Endpoint.h::Endpoint_Read_Stream_LE" ref="a4338c8a0949610ff395076c836ea8f2" args="(void *Buffer, uint16_t Length, uint8_t(*const Callback)(void)) ATTR_NON_NULL_PTR_ARG(1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t Endpoint_Read_Stream_LE           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>Buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>Length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t(*)(void)&nbsp;</td>
          <td class="paramname"> <em>Callback</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reads the given number of bytes from the endpoint from the given buffer in little endian, discarding fully read packets from the host as needed. The last packet is not automatically discarded once the remaining bytes has been read; the user is responsible for manually discarding the last packet from the host via the <a class="el" href="../../db/d3a/a00040.html#41d8837f1719203a95724dccc90ec2ee">Endpoint_ClearCurrentBank()</a> macro. Between each USB packet, the given stream callback function is executed repeatedly until the endpoint is ready to accept the next packet, allowing for early aborts of stream transfers.<p>
The callback routine should be created using the <a class="el" href="../../d4/d63/a00082.html#d6e3a0d3480d20e11549313a8d26075c">STREAM_CALLBACK()</a> macro. If the token NO_STREAM_CALLBACKS is passed via the -D option to the compiler, stream callbacks are disabled and this function has the Callback parameter ommitted.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This routine should not be used on CONTROL type endpoints.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Buffer</em>&nbsp;</td><td>Pointer to the destination data buffer to write to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Length</em>&nbsp;</td><td>Number of bytes to send via the currently selected endpoint. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Callback</em>&nbsp;</td><td>Name of a callback routine to call between sucessive USB packet transfers, NULL if no callback</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A value from the Endpoint_Stream_RW_ErrorCodes_t enum. </dd></dl>

</div>
</div><p>
<a class="anchor" name="74f1de479c5714213280b079825a4457"></a><!-- doxytag: member="Endpoint.h::Endpoint_Read_Word_BE" ref="74f1de479c5714213280b079825a4457" args="(void) ATTR_WARN_UNUSED_RESULT" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static uint16_t Endpoint_Read_Word_BE           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reads two bytes from the currently selected endpoint's bank in big endian format, for OUT direction endpoints. 
</div>
</div><p>
<a class="anchor" name="94403bf97351658c2df36a396f382a86"></a><!-- doxytag: member="Endpoint.h::Endpoint_Read_Word_LE" ref="94403bf97351658c2df36a396f382a86" args="(void) ATTR_WARN_UNUSED_RESULT" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static uint16_t Endpoint_Read_Word_LE           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reads two bytes from the currently selected endpoint's bank in little endian format, for OUT direction endpoints. 
</div>
</div><p>
<a class="anchor" name="2ee0f0710d9f319a5d5d13f1b6019488"></a><!-- doxytag: member="Endpoint.h::Endpoint_WaitUntilReady" ref="2ee0f0710d9f319a5d5d13f1b6019488" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t Endpoint_WaitUntilReady           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Spinloops until the currently selected non-control endpoint is ready for the next packet of data to be read or written to it.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This routine should not be called on CONTROL type endpoints.</dd></dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A value from the Endpoint_WaitUntilReady_ErrorCodes_t enum. </dd></dl>

</div>
</div><p>
<a class="anchor" name="0ff8109e059d7148abc542d2c79e0781"></a><!-- doxytag: member="Endpoint.h::Endpoint_Write_Byte" ref="0ff8109e059d7148abc542d2c79e0781" args="(const uint8_t Byte)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void Endpoint_Write_Byte           </td>
          <td>(</td>
          <td class="paramtype">const uint8_t&nbsp;</td>
          <td class="paramname"> <em>Byte</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Writes one byte from the currently selected endpoint's bank, for IN direction endpoints. 
</div>
</div><p>
<a class="anchor" name="e2ebee942dae1fe0fb6406583758a101"></a><!-- doxytag: member="Endpoint.h::Endpoint_Write_Control_Stream_BE" ref="e2ebee942dae1fe0fb6406583758a101" args="(const void *Buffer, uint16_t Length) ATTR_NON_NULL_PTR_ARG(1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t Endpoint_Write_Control_Stream_BE           </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>Buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>Length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Writes the given number of bytes to the CONTROL type endpoint from the given buffer in big endian, sending full packets to the host as needed. The host OUT acknowedgement is not automatically cleared in both failure and success states; the user is responsible for manually clearing the setup OUT to finalize the transfer via the <a class="el" href="../../db/d3a/a00040.html#e99e315647dbf4a2464dce3a2f2659a6">Endpoint_ClearSetupOUT()</a> macro.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This routine should only be used on CONTROL type endpoints.</dd></dl>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>Unlike the standard stream read/write commands, the control stream commands cannot be chained together; i.e. the entire stream data must be read or written at the one time.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Buffer</em>&nbsp;</td><td>Pointer to the source data buffer to read from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Length</em>&nbsp;</td><td>Number of bytes to read for the currently selected endpoint into the buffer.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A value from the Endpoint_ControlStream_RW_ErrorCodes_t enum. </dd></dl>

</div>
</div><p>
<a class="anchor" name="b28db1e015f6ccb22987551f0b4b7bb4"></a><!-- doxytag: member="Endpoint.h::Endpoint_Write_Control_Stream_LE" ref="b28db1e015f6ccb22987551f0b4b7bb4" args="(const void *Buffer, uint16_t Length) ATTR_NON_NULL_PTR_ARG(1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t Endpoint_Write_Control_Stream_LE           </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>Buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>Length</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Writes the given number of bytes to the CONTROL type endpoint from the given buffer in little endian, sending full packets to the host as needed. The host OUT acknowedgement is not automatically cleared in both failure and success states; the user is responsible for manually clearing the setup OUT to finalize the transfer via the <a class="el" href="../../db/d3a/a00040.html#e99e315647dbf4a2464dce3a2f2659a6">Endpoint_ClearSetupOUT()</a> macro.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This routine should only be used on CONTROL type endpoints.</dd></dl>
<dl class="warning" compact><dt><b>Warning:</b></dt><dd>Unlike the standard stream read/write commands, the control stream commands cannot be chained together; i.e. the entire stream data must be read or written at the one time.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Buffer</em>&nbsp;</td><td>Pointer to the source data buffer to read from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Length</em>&nbsp;</td><td>Number of bytes to read for the currently selected endpoint into the buffer.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A value from the Endpoint_ControlStream_RW_ErrorCodes_t enum. </dd></dl>

</div>
</div><p>
<a class="anchor" name="1015ec8ddf4e8a9df724f5f5f6e748e6"></a><!-- doxytag: member="Endpoint.h::Endpoint_Write_DWord_BE" ref="1015ec8ddf4e8a9df724f5f5f6e748e6" args="(const uint32_t DWord)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void Endpoint_Write_DWord_BE           </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&nbsp;</td>
          <td class="paramname"> <em>DWord</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Writes four bytes to the currently selected endpoint's bank in big endian format, for IN direction endpoints. 
</div>
</div><p>
<a class="anchor" name="3ad2799fe37080f4cfadc3c2c18fcbc3"></a><!-- doxytag: member="Endpoint.h::Endpoint_Write_DWord_LE" ref="3ad2799fe37080f4cfadc3c2c18fcbc3" args="(const uint32_t DWord)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void Endpoint_Write_DWord_LE           </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&nbsp;</td>
          <td class="paramname"> <em>DWord</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Writes four bytes to the currently selected endpoint's bank in little endian format, for IN direction endpoints. 
</div>
</div><p>
<a class="anchor" name="ae941ffeae4a40f72e989ffcd09626dd"></a><!-- doxytag: member="Endpoint.h::Endpoint_Write_Stream_BE" ref="ae941ffeae4a40f72e989ffcd09626dd" args="(const void *Buffer, uint16_t Length, uint8_t(*const Callback)(void)) ATTR_NON_NULL_PTR_ARG(1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t Endpoint_Write_Stream_BE           </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>Buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>Length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t(*)(void)&nbsp;</td>
          <td class="paramname"> <em>Callback</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Writes the given number of bytes to the endpoint from the given buffer in big endian, sending full packets to the host as needed. The last packet filled is not automatically sent; the user is responsible for manually sending the last written packet to the host via the <a class="el" href="../../db/d3a/a00040.html#41d8837f1719203a95724dccc90ec2ee">Endpoint_ClearCurrentBank()</a> macro. Between each USB packet, the given stream callback function is executed repeatedly until the endpoint is ready to accept the next packet, allowing for early aborts of stream transfers.<p>
The callback routine should be created using the <a class="el" href="../../d4/d63/a00082.html#d6e3a0d3480d20e11549313a8d26075c">STREAM_CALLBACK()</a> macro. If the token NO_STREAM_CALLBACKS is passed via the -D option to the compiler, stream callbacks are disabled and this function has the Callback parameter ommitted.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This routine should not be used on CONTROL type endpoints.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Buffer</em>&nbsp;</td><td>Pointer to the source data buffer to read from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Length</em>&nbsp;</td><td>Number of bytes to read for the currently selected endpoint into the buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Callback</em>&nbsp;</td><td>Name of a callback routine to call between sucessive USB packet transfers, NULL if no callback</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A value from the Endpoint_Stream_RW_ErrorCodes_t enum. </dd></dl>

</div>
</div><p>
<a class="anchor" name="4ec7ef0303a01e1032c022c397995734"></a><!-- doxytag: member="Endpoint.h::Endpoint_Write_Stream_LE" ref="4ec7ef0303a01e1032c022c397995734" args="(const void *Buffer, uint16_t Length, uint8_t(*const Callback)(void)) ATTR_NON_NULL_PTR_ARG(1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t Endpoint_Write_Stream_LE           </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>Buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>Length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t(*)(void)&nbsp;</td>
          <td class="paramname"> <em>Callback</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Writes the given number of bytes to the endpoint from the given buffer in little endian, sending full packets to the host as needed. The last packet filled is not automatically sent; the user is responsible for manually sending the last written packet to the host via the <a class="el" href="../../db/d3a/a00040.html#41d8837f1719203a95724dccc90ec2ee">Endpoint_ClearCurrentBank()</a> macro. Between each USB packet, the given stream callback function is executed repeatedly until the endpoint is ready to accept the next packet, allowing for early aborts of stream transfers.<p>
The callback routine should be created using the <a class="el" href="../../d4/d63/a00082.html#d6e3a0d3480d20e11549313a8d26075c">STREAM_CALLBACK()</a> macro. If the token NO_STREAM_CALLBACKS is passed via the -D option to the compiler, stream callbacks are disabled and this function has the Callback parameter ommitted.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This routine should not be used on CONTROL type endpoints.</dd></dl>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Buffer</em>&nbsp;</td><td>Pointer to the source data buffer to read from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Length</em>&nbsp;</td><td>Number of bytes to read for the currently selected endpoint into the buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Callback</em>&nbsp;</td><td>Name of a callback routine to call between sucessive USB packet transfers, NULL if no callback</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A value from the Endpoint_Stream_RW_ErrorCodes_t enum. </dd></dl>

</div>
</div><p>
<a class="anchor" name="04bb808c3cf7c43144634383e5c82817"></a><!-- doxytag: member="Endpoint.h::Endpoint_Write_Word_BE" ref="04bb808c3cf7c43144634383e5c82817" args="(const uint16_t Word)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void Endpoint_Write_Word_BE           </td>
          <td>(</td>
          <td class="paramtype">const uint16_t&nbsp;</td>
          <td class="paramname"> <em>Word</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Writes two bytes to the currently selected endpoint's bank in big endian format, for IN direction endpoints. 
</div>
</div><p>
<a class="anchor" name="42b74e033b75075fa6d3c20b19e5ba8a"></a><!-- doxytag: member="Endpoint.h::Endpoint_Write_Word_LE" ref="42b74e033b75075fa6d3c20b19e5ba8a" args="(const uint16_t Word)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void Endpoint_Write_Word_LE           </td>
          <td>(</td>
          <td class="paramtype">const uint16_t&nbsp;</td>
          <td class="paramname"> <em>Word</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Writes two bytes to the currently selected endpoint's bank in little endian format, for IN direction endpoints. 
</div>
</div><p>
<hr><h2>Variable Documentation</h2>
<a class="anchor" name="8422610dc18164a09618d82b9306c365"></a><!-- doxytag: member="Endpoint.h::USB_ControlEndpointSize" ref="8422610dc18164a09618d82b9306c365" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t <a class="el" href="../../db/d3a/a00040.html#8422610dc18164a09618d82b9306c365">USB_ControlEndpointSize</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Global indicating the maximum packet size of the default control endpoint located at address 0 in the device. This value is set to the value indicated in the device descriptor in the user project once the USB interface is initialized into device mode.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This variable should be treated as read-only in the user application, and never manually changed in value. </dd></dl>

</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Thu Oct 2 18:01:17 2008 for MyUSB Library by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.5 </small></address>
</body>
</html>
