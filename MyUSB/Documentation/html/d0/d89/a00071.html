<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>MyUSB Library: Pipe.h File Reference</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
<link href="../../tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.5 -->
<script type="text/javascript">
<!--
function changeDisplayState (e){
  var num=this.id.replace(/[^[0-9]/g,'');
  var button=this.firstChild;
  var sectionDiv=document.getElementById('dynsection'+num);
  if (sectionDiv.style.display=='none'||sectionDiv.style.display==''){
    sectionDiv.style.display='block';
    button.src='../../open.gif';
  }else{
    sectionDiv.style.display='none';
    button.src='../../closed.gif';
  }
}
function initDynSections(){
  var divs=document.getElementsByTagName('div');
  var sectionCounter=1;
  for(var i=0;i<divs.length-1;i++){
    if(divs[i].className=='dynheader'&&divs[i+1].className=='dynsection'){
      var header=divs[i];
      var section=divs[i+1];
      var button=header.firstChild;
      if (button!='IMG'){
        divs[i].insertBefore(document.createTextNode(' '),divs[i].firstChild);
        button=document.createElement('img');
        divs[i].insertBefore(button,divs[i].firstChild);
      }
      header.style.cursor='pointer';
      header.onclick=changeDisplayState;
      header.id='dynheader'+sectionCounter;
      button.src='../../closed.gif';
      section.id='dynsection'+sectionCounter;
      section.style.display='none';
      section.style.marginLeft='14px';
      sectionCounter++;
    }
  }
}
window.onload = initDynSections;
-->
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="../../main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="../../pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="../../classes.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="../../files.html"><span>Files</span></a></li>
      <li><a href="../../dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="../../dir_2e1fbef791c6441b28631243cfb4eaa5.html">MyUSB</a>&nbsp;&raquo&nbsp;<a class="el" href="../../dir_88a6e91c5675e76375b47b277a58e3e8.html">Drivers</a>&nbsp;&raquo&nbsp;<a class="el" href="../../dir_cf4f163638ad68cd11bd930d84c7b552.html">USB</a>&nbsp;&raquo&nbsp;<a class="el" href="../../dir_b1006f5156f0bb4cb34454f31590fa7a.html">LowLevel</a>
  </div>
</div>
<div class="contents">
<h1>Pipe.h File Reference</h1><code>#include &lt;avr/io.h&gt;</code><br>
<code>#include &lt;stdbool.h&gt;</code><br>
<code>#include &quot;<a class="el" href="../../d3/dfe/a00025.html">../../../Common/Common.h</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="../../d9/dec/a00090.html">../HighLevel/USBTask.h</a>&quot;</code><br>
<code>#include &quot;<a class="el" href="../../d4/d63/a00082.html">StreamCallbacks.h</a>&quot;</code><br>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d89/a00071.html#523291f171ce8bbcad293302c702fff1">PIPE_ERRORFLAG_CRC16</a>&nbsp;&nbsp;&nbsp;(1 &lt;&lt; 4)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d89/a00071.html#5ba4ba74769293d65b32109e50a9e2d4">PIPE_ERRORFLAG_TIMEOUT</a>&nbsp;&nbsp;&nbsp;(1 &lt;&lt; 3)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d89/a00071.html#6758ca70b0917fb4076a8d4d2f6dd3f4">PIPE_ERRORFLAG_PID</a>&nbsp;&nbsp;&nbsp;(1 &lt;&lt; 2)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d89/a00071.html#69a45a7966eea73ea92d663b68748abd">PIPE_ERRORFLAG_DATAPID</a>&nbsp;&nbsp;&nbsp;(1 &lt;&lt; 1)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d89/a00071.html#5b587ec7e9f0fc14d601bc6f9472bfdc">PIPE_ERRORFLAG_DATATGL</a>&nbsp;&nbsp;&nbsp;(1 &lt;&lt; 0)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d89/a00071.html#23184c2580f8241fcc6c27c0a580706d">PIPE_TOKEN_SETUP</a>&nbsp;&nbsp;&nbsp;(0b00 &lt;&lt; PTOKEN0)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d89/a00071.html#aad74ddaafc14770bfd3902e202658ee">PIPE_TOKEN_IN</a>&nbsp;&nbsp;&nbsp;(0b01 &lt;&lt; PTOKEN0)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d89/a00071.html#9d95c915c1f2fa07ecdcd1d08027ec40">PIPE_TOKEN_OUT</a>&nbsp;&nbsp;&nbsp;(0b10 &lt;&lt; PTOKEN0)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d89/a00071.html#7f8b77f0483c04a394f4123795e5b2b6">PIPE_BANK_SINGLE</a>&nbsp;&nbsp;&nbsp;0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d89/a00071.html#0ca034789b58d9fe337efb79c19797dd">PIPE_BANK_DOUBLE</a>&nbsp;&nbsp;&nbsp;(1 &lt;&lt; EPBK0)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d89/a00071.html#8114af361d1f52cc6e47447c9484ae98">PIPE_CONTROLPIPE</a>&nbsp;&nbsp;&nbsp;0</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d89/a00071.html#0dc275b75a1bccc1b51dd78ef1485e2e">PIPE_CONTROLPIPE_DEFAULT_SIZE</a>&nbsp;&nbsp;&nbsp;8</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d89/a00071.html#d7d98398d5e1509886cc458ba99cbff8">PIPE_PIPENUM_MASK</a>&nbsp;&nbsp;&nbsp;0x07</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d89/a00071.html#6fbf2b826d418d254807eb6fac814ca2">PIPE_MAX_PIPES</a>&nbsp;&nbsp;&nbsp;7</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d89/a00071.html#ab4f0d06a298c058d074511c4d22dede">PIPE_MAX_SIZE</a>&nbsp;&nbsp;&nbsp;256</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d89/a00071.html#f792d5d32653e0e7dac1103701636162">PIPE_EPNUM_MASK</a>&nbsp;&nbsp;&nbsp;0x07</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d89/a00071.html#52e4b610427b58ec8be83efcd074a028">PIPE_EPSIZE_MASK</a>&nbsp;&nbsp;&nbsp;0x7FF</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d89/a00071.html#976e9458f1d438d081e4f4db9e30c88e">PIPE_INT_IN</a>&nbsp;&nbsp;&nbsp;UPIENX, (1 &lt;&lt; RXINE) , UPINTX, (1 &lt;&lt; RXINI)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d89/a00071.html#87d1066bebfbbb07272c8e249f440718">PIPE_INT_OUT</a>&nbsp;&nbsp;&nbsp;UPIENX, (1 &lt;&lt; TXOUTE), UPINTX, (1 &lt;&lt; TXOUTI)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d89/a00071.html#4d98daa30c1d0b57af528edd82edd358">PIPE_INT_SETUP</a>&nbsp;&nbsp;&nbsp;UPIENX, (1 &lt;&lt; TXSTPE) , UPINTX, (1 &lt;&lt; TXSTPI)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d89/a00071.html#f5a17f07615300c63c2a3ace1282223f">PIPE_INT_ERROR</a>&nbsp;&nbsp;&nbsp;UPIENX, (1 &lt;&lt; PERRE), UPINTX, (1 &lt;&lt; PERRI)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d89/a00071.html#d6a545d297025b1d83c986a9859e7c58">PIPE_INT_NAK</a>&nbsp;&nbsp;&nbsp;UPIENX, (1 &lt;&lt; NAKEDE), UPINTX, (1 &lt;&lt; NAKEDI)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d89/a00071.html#64d01bc3bc4dc2e3dccd74a70782e768">PIPE_INT_STALL</a>&nbsp;&nbsp;&nbsp;UPIENX, (1 &lt;&lt; RXSTALLE), UPINTX, (1 &lt;&lt; RXSTALLI)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d89/a00071.html#511401246d4cf58ccef037a90b71b037">Pipe_BytesInPipe</a>()&nbsp;&nbsp;&nbsp;UPBCX</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d89/a00071.html#aa5c54e51f9c0afab134d4aca9a9ab5d">Pipe_ResetPipe</a>(pipenum)&nbsp;&nbsp;&nbsp;MACROS{ UPRST    =  (1 &lt;&lt; pipenum); UPRST = 0;                  }MACROE</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d89/a00071.html#bed265b616eb42f47825f03c8013c2e7">Pipe_SelectPipe</a>(pipenum)&nbsp;&nbsp;&nbsp;MACROS{ UPNUM    =  pipenum;                                    }MACROE</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d89/a00071.html#c135a6afb58a6675da7e82a0e6586be8">Pipe_GetCurrentPipe</a>()&nbsp;&nbsp;&nbsp;(UPNUM   &amp;   PIPE_PIPENUM_MASK)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d89/a00071.html#521da7ce84920dfd4a56568d4876bedd">Pipe_EnablePipe</a>()&nbsp;&nbsp;&nbsp;MACROS{ UPCONX  |=  (1 &lt;&lt; PEN);                                 }MACROE</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d89/a00071.html#f79d7cbfe6295a894303f15681f75b08">Pipe_DisablePipe</a>()&nbsp;&nbsp;&nbsp;MACROS{ UPCONX  &amp;= ~(1 &lt;&lt; PEN);                                 }MACROE</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d89/a00071.html#4c4f9dd8698d2c60bb7da0968ee11720">Pipe_IsEnabled</a>()&nbsp;&nbsp;&nbsp;((UPCONX  &amp;   (1 &lt;&lt; PEN)) ? true : false)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d89/a00071.html#3965c03b31bb6f8312847cc4aeb1ff70">Pipe_SetToken</a>(token)&nbsp;&nbsp;&nbsp;MACROS{ UPCFG0X  = ((UPCFG0X &amp; ~PIPE_TOKEN_MASK) | token);      }MACROE</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d89/a00071.html#861e95429a7247a658dc969fa7186a12">Pipe_SetInfiniteINRequests</a>()&nbsp;&nbsp;&nbsp;MACROS{ UPCONX  |=  (1 &lt;&lt; INMODE);                              }MACROE</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d89/a00071.html#6a1ee11059a805a7d06e0d577a4bfddf">Pipe_SetFiniteINRequests</a>(n)&nbsp;&nbsp;&nbsp;MACROS{ UPCONX  &amp;= ~(1 &lt;&lt; INMODE); UPINRQX = n;                 }MACROE</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d89/a00071.html#7440ba6076dc942cbbee1ee4cf60db9b">Pipe_ConfigurePipe</a>(num, type, token, epnum, size, banks)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d89/a00071.html#55d35cf0e4582c79d4da5112d1b22d7d">Pipe_IsConfigured</a>()&nbsp;&nbsp;&nbsp;((UPSTAX  &amp; (1 &lt;&lt; CFGOK)) ? true : false)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d89/a00071.html#ddad91ae4c2bc3f4ed1ecd1121dc1168">Pipe_SetInterruptPeriod</a>(ms)&nbsp;&nbsp;&nbsp;MACROS{ UPCFG2X  = ms;                                          }MACROE</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d89/a00071.html#0ff2442c444be0dc9b539d03498d4051">Pipe_GetPipeInterrupts</a>()&nbsp;&nbsp;&nbsp;UPINT</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d89/a00071.html#d42f919073d432aa1db07ba2f5f7fc58">Pipe_ClearPipeInterrupt</a>(n)&nbsp;&nbsp;&nbsp;MACROS{ UPINT   &amp;= ~(1 &lt;&lt; n);                                   }MACROE</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d89/a00071.html#69165c3df4e014e158454a0b1c9f57d3">Pipe_HasPipeInterrupted</a>(n)&nbsp;&nbsp;&nbsp;((UPINT   &amp;   (1 &lt;&lt; n)) ? true : false)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d89/a00071.html#432c04eb14903b47e9d5322fc4673360">Pipe_ClearCurrentBank</a>()&nbsp;&nbsp;&nbsp;MACROS{ UPINTX  &amp;= ~(1 &lt;&lt; FIFOCON);                             }MACROE</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d89/a00071.html#9ef14dd97b9c5a69089e7e59aa5e4485">Pipe_Unfreeze</a>()&nbsp;&nbsp;&nbsp;MACROS{ UPCONX  &amp;= ~(1 &lt;&lt; PFREEZE);                             }MACROE</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d89/a00071.html#7811fe4fbee7d93d7c09ac2c1d7e3408">Pipe_Freeze</a>()&nbsp;&nbsp;&nbsp;MACROS{ UPCONX  |=  (1 &lt;&lt; PFREEZE);                             }MACROE</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d89/a00071.html#81bdbe2403509d71561938454c7dbfe8">Pipe_ClearError</a>()&nbsp;&nbsp;&nbsp;MACROS{ UPINTX  &amp;= ~(1 &lt;&lt; PERRI);                               }MACROE</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d89/a00071.html#eefd3c22c8671942ad0b024564210d58">Pipe_IsError</a>()&nbsp;&nbsp;&nbsp;((UPINTX  &amp;   (1 &lt;&lt; PERRI)) ? true : false)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d89/a00071.html#68cde4dceaa46f68323dacab82c493ad">Pipe_ClearErrorFlags</a>()&nbsp;&nbsp;&nbsp;MACROS{ UPERRX   = 0;                                           }MACROE</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d89/a00071.html#8d68ec1831a407f8f19ebab1ec990708">Pipe_GetErrorFlags</a>()&nbsp;&nbsp;&nbsp;UPERRX</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d89/a00071.html#5cce6692d5697e5fc9cb47c0e916dde4">Pipe_ReadWriteAllowed</a>()&nbsp;&nbsp;&nbsp;((UPINTX  &amp; (1 &lt;&lt; RWAL)) ? true : false)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d89/a00071.html#a3e799d50baf113794790910508cc5c4">Pipe_ClearSetupSent</a>()&nbsp;&nbsp;&nbsp;MACROS{ UPINTX  &amp;= ~(1 &lt;&lt; TXSTPI);                              }MACROE</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d89/a00071.html#9c9c9ce726ba81441b84d1ea3ba9d3c5">Pipe_IsSetupSent</a>()&nbsp;&nbsp;&nbsp;((UPINTX  &amp;   (1 &lt;&lt; TXSTPI)) ? true : false)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d89/a00071.html#e2a5bff38979c9ee712102061e9c7ccd">Pipe_IsStalled</a>()&nbsp;&nbsp;&nbsp;((UPINTX  &amp;   (1 &lt;&lt; RXSTALLI)) ? true : false)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d89/a00071.html#440addcb70249fd98f432b8d70c500ea">Pipe_ClearStall</a>()&nbsp;&nbsp;&nbsp;MACROS{ UPINTX  &amp;= ~(1 &lt;&lt; RXSTALLI);                            }MACROE</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d89/a00071.html#6c863fa464d1fab07c7d864cad5b2fc7">Pipe_IsSetupINReceived</a>()&nbsp;&nbsp;&nbsp;((UPINTX  &amp;   (1 &lt;&lt; RXINI)) ? true : false)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d89/a00071.html#75cf698a5511261ebb434bb77f11a345">Pipe_IsSetupOUTReady</a>()&nbsp;&nbsp;&nbsp;((UPINTX  &amp;   (1 &lt;&lt; TXOUTI)) ? true : false)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d89/a00071.html#6ee4730e8c984db74c01ee5eed35c638">Pipe_ClearSetupIN</a>()&nbsp;&nbsp;&nbsp;MACROS{ UPINTX  &amp;= ~(1 &lt;&lt; RXINI); UPINTX &amp;= ~(1 &lt;&lt; FIFOCON);    }MACROE</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d89/a00071.html#bdff36db0ccb854bdc8c4b60cb39a631">Pipe_ClearSetupOUT</a>()&nbsp;&nbsp;&nbsp;MACROS{ UPINTX  &amp;= ~(1 &lt;&lt; TXOUTI); UPINTX &amp;= ~(1 &lt;&lt; FIFOCON);   }MACROE</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d89/a00071.html#fc7477a30fe7f8c8411af1d4a1f293e0">Pipe_IsNAKReceived</a>()&nbsp;&nbsp;&nbsp;((UPINTX &amp; (1 &lt;&lt; NAKEDI)) ? true : false)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d89/a00071.html#aea8042b8877c065abf85e2893dd1228">Pipe_ClearNAKReceived</a>()&nbsp;&nbsp;&nbsp;MACROS{ UPINTX &amp;= ~(1 &lt;&lt; NAKEDI);                              }MACROE</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d89/a00071.html#7239175cf7b3de1f7286b6879c892974">Pipe_Ignore_Byte</a>()&nbsp;&nbsp;&nbsp;Pipe_Discard_Byte()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d89/a00071.html#a6ede08012fd53a072fcbf57a29ac9d9">Pipe_Ignore_Word</a>()&nbsp;&nbsp;&nbsp;Pipe_Discard_Word()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d89/a00071.html#3e88f26f43087f20440787bd13cb0004">Pipe_Ignore_DWord</a>()&nbsp;&nbsp;&nbsp;Pipe_Discard_DWord()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d89/a00071.html#d5622633568640ac4cd8dd60f2907250">Pipe_Read_Word</a>()&nbsp;&nbsp;&nbsp;Pipe_Read_Word_LE()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d89/a00071.html#f0eb734cd675fd9e3246a3dc62c11a16">Pipe_Write_Word</a>(Word)&nbsp;&nbsp;&nbsp;Pipe_Write_Word_LE(Word)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d89/a00071.html#a5d2ba4e45678384a146098faa289b4f">Pipe_Read_DWord</a>()&nbsp;&nbsp;&nbsp;Pipe_Read_DWord_LE()</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d89/a00071.html#0d76013bb35096aff7765a9ea006e6b9">Pipe_Write_DWord</a>(DWord)&nbsp;&nbsp;&nbsp;Pipe_Write_DWord_LE(DWord)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d89/a00071.html#72f771b62120aeb8c5d663d38f733fa0">Pipe_Read_Stream</a>(Buffer, Length, Callback)&nbsp;&nbsp;&nbsp;Pipe_Read_Stream_LE(Buffer, Length, Callback)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d89/a00071.html#e18b1181009aaf36ba0470e93c052f24">Pipe_Write_Stream</a>(Buffer, Length, Callback)&nbsp;&nbsp;&nbsp;Pipe_Read_Stream_LE(Buffer, Length, Callback)</td></tr>

<tr><td colspan="2"><br><h2>Enumerations</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d89/a00071.html#fe05d0620e5882aced3764a691a11152">Pipe_WaitUntilReady_ErrorCodes_t</a> { <br>
&nbsp;&nbsp;<a class="el" href="../../d0/d89/a00071.html#fe05d0620e5882aced3764a691a11152a76ab88bf27a7a9cf3cd489229e0ef8a">PIPE_READYWAIT_NoError</a> =  0, 
<br>
&nbsp;&nbsp;<a class="el" href="../../d0/d89/a00071.html#fe05d0620e5882aced3764a691a1115233cd79b9ef1b7b85107ffafc28c32c81">PIPE_READYWAIT_PipeStalled</a> =  1, 
<br>
&nbsp;&nbsp;<a class="el" href="../../d0/d89/a00071.html#fe05d0620e5882aced3764a691a11152e4befd28416d0bb3b5f0c5fb8693b192">PIPE_READYWAIT_DeviceDisconnected</a> =  2, 
<br>
&nbsp;&nbsp;<a class="el" href="../../d0/d89/a00071.html#fe05d0620e5882aced3764a691a111525e2a8c840c4a5756ebd426f935f18f20">PIPE_READYWAIT_Timeout</a> =  3
<br>
 }</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">enum &nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d89/a00071.html#b83460617bb7a5c928308a71307f237c">Pipe_Stream_RW_ErrorCodes_t</a> { <br>
&nbsp;&nbsp;<a class="el" href="../../d0/d89/a00071.html#b83460617bb7a5c928308a71307f237cce38ad06e68219be2cf49781efed2ea2">PIPE_RWSTREAM_ERROR_NoError</a> =  0, 
<br>
&nbsp;&nbsp;<a class="el" href="../../d0/d89/a00071.html#b83460617bb7a5c928308a71307f237c03f7aa65e828a45baf1436b2b018a571">PIPE_RWSTREAM_ERROR_PipeStalled</a> =  1, 
<br>
&nbsp;&nbsp;<a class="el" href="../../d0/d89/a00071.html#b83460617bb7a5c928308a71307f237c549820a0ef14b68243af5bd9bc62f8c8">PIPE_RWSTREAM_ERROR_DeviceDisconnected</a> =  2, 
<br>
&nbsp;&nbsp;<a class="el" href="../../d0/d89/a00071.html#b83460617bb7a5c928308a71307f237c1ce48b47cb4e91de8c117ebe925c4b8d">PIPE_RWSTREAM_ERROR_Timeout</a> =  3, 
<br>
&nbsp;&nbsp;<a class="el" href="../../d0/d89/a00071.html#b83460617bb7a5c928308a71307f237c5a1a76d2ebd66854bfc3abc1a9088480">PIPE_RWSTREAM_ERROR_CallbackAborted</a> =  4
<br>
 }</td></tr>

<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">static uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d89/a00071.html#f97bf18ff71bb8d38a29e735add628c9">Pipe_Read_Byte</a> (void) ATTR_WARN_UNUSED_RESULT</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d89/a00071.html#40f86cc79768d0113c296378efe8bbcd">Pipe_Write_Byte</a> (const uint8_t Byte)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d89/a00071.html#e144e7739a66f9dbb1747d168ae20d58">Pipe_Discard_Byte</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static uint16_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d89/a00071.html#0b0926d50ccf4ef5af1af2bc448ee088">Pipe_Read_Word_LE</a> (void) ATTR_WARN_UNUSED_RESULT</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static uint16_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d89/a00071.html#1b817b4e70ad368b1e5b3eef82703d55">Pipe_Read_Word_BE</a> (void) ATTR_WARN_UNUSED_RESULT</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d89/a00071.html#2e6398dd044bc3c9f9eb1da4c6f76010">Pipe_Write_Word_LE</a> (const uint16_t Word)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d89/a00071.html#11bcfcea2698991075d7c3db40f9cf89">Pipe_Write_Word_BE</a> (const uint16_t Word)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d89/a00071.html#15cb7c4e354a3cece0d477ade632838d">Pipe_Read_DWord_LE</a> (void) ATTR_WARN_UNUSED_RESULT</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static uint32_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d89/a00071.html#4a6d0b211f6294f80c98cf3199a1d66c">Pipe_Read_DWord_BE</a> (void) ATTR_WARN_UNUSED_RESULT</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d89/a00071.html#c4b3a34f538ea17df6e787138f32e3e6">Pipe_Write_DWord_LE</a> (const uint32_t DWord)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">static void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d89/a00071.html#f575d5460ffe1ce56f20872f9daaa340">Pipe_Write_DWord_BE</a> (const uint32_t DWord)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d89/a00071.html#cb9093cfd973aa4b51fff09cfaa53ba9">Pipe_WaitUntilReady</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d89/a00071.html#6c717328b7421d277ef5ec727779da8d">Pipe_Write_Stream_LE</a> (const void *Buffer, uint16_t Length, uint8_t(*const Callback)(void)) ATTR_NON_NULL_PTR_ARG(1)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d89/a00071.html#63143341fde11dc535188184b6977e48">Pipe_Write_Stream_BE</a> (const void *Buffer, uint16_t Length, uint8_t(*const Callback)(void)) ATTR_NON_NULL_PTR_ARG(1)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d89/a00071.html#01b068e18872cf93db73777e6c93a775">Pipe_Discard_Stream</a> (uint16_t Length, uint8_t(*const Callback)(void))</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d89/a00071.html#49a2264c02c6f6eb6471a3cce6e1423f">Pipe_Read_Stream_LE</a> (void *Buffer, uint16_t Length, uint8_t(*const Callback)(void)) ATTR_NON_NULL_PTR_ARG(1)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d89/a00071.html#b9c0b49a7853725c1570af6e0a55ca97">Pipe_Read_Stream_BE</a> (void *Buffer, uint16_t Length, uint8_t(*const Callback)(void)) ATTR_NON_NULL_PTR_ARG(1)</td></tr>

<tr><td colspan="2"><br><h2>Variables</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">uint8_t&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d89/a00071.html#d76597acf13d471a30ff9785b94b01e2">USB_ControlPipeSize</a></td></tr>

</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
Functions, macros and enums related to pipe management when in USB Host mode. This module contains the pipe management macros, as well as pipe interrupt and data send/recieve functions for various datatypes. <hr><h2>Define Documentation</h2>
<a class="anchor" name="0ca034789b58d9fe337efb79c19797dd"></a><!-- doxytag: member="Pipe.h::PIPE_BANK_DOUBLE" ref="0ca034789b58d9fe337efb79c19797dd" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PIPE_BANK_DOUBLE&nbsp;&nbsp;&nbsp;(1 &lt;&lt; EPBK0)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Mask for the bank mode selection for the <a class="el" href="../../d0/d89/a00071.html#7440ba6076dc942cbbee1ee4cf60db9b">Pipe_ConfigurePipe()</a> macro. This indicates that the pipe should have two banks, which requires more USB FIFO memory but results in faster transfers as one USB device (the AVR or the attached device) can access one bank while the other accesses the second bank. 
</div>
</div><p>
<a class="anchor" name="7f8b77f0483c04a394f4123795e5b2b6"></a><!-- doxytag: member="Pipe.h::PIPE_BANK_SINGLE" ref="7f8b77f0483c04a394f4123795e5b2b6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PIPE_BANK_SINGLE&nbsp;&nbsp;&nbsp;0          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Mask for the bank mode selection for the <a class="el" href="../../d0/d89/a00071.html#7440ba6076dc942cbbee1ee4cf60db9b">Pipe_ConfigurePipe()</a> macro. This indicates that the pipe should have one single bank, which requires less USB FIFO memory but results in slower transfers as only one USB device (the AVR or the attached device) can access the pipe's bank at the one time. 
</div>
</div><p>
<a class="anchor" name="511401246d4cf58ccef037a90b71b037"></a><!-- doxytag: member="Pipe.h::Pipe_BytesInPipe" ref="511401246d4cf58ccef037a90b71b037" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Pipe_BytesInPipe          </td>
          <td>(</td>
&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;UPBCX</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Indicates the number of bytes currently stored in the current pipe's selected bank. 
</div>
</div><p>
<a class="anchor" name="432c04eb14903b47e9d5322fc4673360"></a><!-- doxytag: member="Pipe.h::Pipe_ClearCurrentBank" ref="432c04eb14903b47e9d5322fc4673360" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Pipe_ClearCurrentBank          </td>
          <td>(</td>
&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;MACROS{ UPINTX  &amp;= ~(1 &lt;&lt; FIFOCON);                             }MACROE</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Clears the pipe bank, and switches to the alternate bank if the currently selected pipe is dual-banked. When cleared, this either frees the bank up for the next packet from the host (if the endpoint is of the OUT direction) or sends the packet contents to the host (if the pipe is of the IN direction). 
</div>
</div><p>
<a class="anchor" name="81bdbe2403509d71561938454c7dbfe8"></a><!-- doxytag: member="Pipe.h::Pipe_ClearError" ref="81bdbe2403509d71561938454c7dbfe8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Pipe_ClearError          </td>
          <td>(</td>
&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;MACROS{ UPINTX  &amp;= ~(1 &lt;&lt; PERRI);                               }MACROE</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Clears the master pipe error flag. 
</div>
</div><p>
<a class="anchor" name="68cde4dceaa46f68323dacab82c493ad"></a><!-- doxytag: member="Pipe.h::Pipe_ClearErrorFlags" ref="68cde4dceaa46f68323dacab82c493ad" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Pipe_ClearErrorFlags          </td>
          <td>(</td>
&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;MACROS{ UPERRX   = 0;                                           }MACROE</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Clears all the currently selected pipe's hardware error flags, but does not clear the master error flag for the pipe. 
</div>
</div><p>
<a class="anchor" name="aea8042b8877c065abf85e2893dd1228"></a><!-- doxytag: member="Pipe.h::Pipe_ClearNAKReceived" ref="aea8042b8877c065abf85e2893dd1228" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Pipe_ClearNAKReceived          </td>
          <td>(</td>
&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;MACROS{ UPINTX &amp;= ~(1 &lt;&lt; NAKEDI);                              }MACROE</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Clears the NAK condition on the currently selected pipe.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="../../d0/d89/a00071.html#fc7477a30fe7f8c8411af1d4a1f293e0">Pipe_IsNAKReceived()</a> for more details. </dd></dl>

</div>
</div><p>
<a class="anchor" name="d42f919073d432aa1db07ba2f5f7fc58"></a><!-- doxytag: member="Pipe.h::Pipe_ClearPipeInterrupt" ref="d42f919073d432aa1db07ba2f5f7fc58" args="(n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Pipe_ClearPipeInterrupt          </td>
          <td>(</td>
          <td class="paramtype">n&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;MACROS{ UPINT   &amp;= ~(1 &lt;&lt; n);                                   }MACROE</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Clears the interrupt flag for the specified pipe number. 
</div>
</div><p>
<a class="anchor" name="6ee4730e8c984db74c01ee5eed35c638"></a><!-- doxytag: member="Pipe.h::Pipe_ClearSetupIN" ref="6ee4730e8c984db74c01ee5eed35c638" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Pipe_ClearSetupIN          </td>
          <td>(</td>
&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;MACROS{ UPINTX  &amp;= ~(1 &lt;&lt; RXINI); UPINTX &amp;= ~(1 &lt;&lt; FIFOCON);    }MACROE</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Acknowedges the reception of a setup IN request from the attached device on the currently selected CONTROL type endpoint, allowing for the transmission of a setup OUT packet, or the reception of another setup IN packet. 
</div>
</div><p>
<a class="anchor" name="bdff36db0ccb854bdc8c4b60cb39a631"></a><!-- doxytag: member="Pipe.h::Pipe_ClearSetupOUT" ref="bdff36db0ccb854bdc8c4b60cb39a631" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Pipe_ClearSetupOUT          </td>
          <td>(</td>
&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;MACROS{ UPINTX  &amp;= ~(1 &lt;&lt; TXOUTI); UPINTX &amp;= ~(1 &lt;&lt; FIFOCON);   }MACROE</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sends the currently selected CONTROL type pipe's contents to the device as a setup OUT packet. 
</div>
</div><p>
<a class="anchor" name="a3e799d50baf113794790910508cc5c4"></a><!-- doxytag: member="Pipe.h::Pipe_ClearSetupSent" ref="a3e799d50baf113794790910508cc5c4" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Pipe_ClearSetupSent          </td>
          <td>(</td>
&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;MACROS{ UPINTX  &amp;= ~(1 &lt;&lt; TXSTPI);                              }MACROE</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Clears the flag indicating that a SETUP request has been sent to the attached device from the currently selected CONTROL type pipe. 
</div>
</div><p>
<a class="anchor" name="440addcb70249fd98f432b8d70c500ea"></a><!-- doxytag: member="Pipe.h::Pipe_ClearStall" ref="440addcb70249fd98f432b8d70c500ea" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Pipe_ClearStall          </td>
          <td>(</td>
&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;MACROS{ UPINTX  &amp;= ~(1 &lt;&lt; RXSTALLI);                            }MACROE</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Clears the stall condition on the currently selected pipe. 
</div>
</div><p>
<a class="anchor" name="7440ba6076dc942cbbee1ee4cf60db9b"></a><!-- doxytag: member="Pipe.h::Pipe_ConfigurePipe" ref="7440ba6076dc942cbbee1ee4cf60db9b" args="(num, type, token, epnum, size, banks)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Pipe_ConfigurePipe          </td>
          <td>(</td>
          <td class="paramtype">num,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">type,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">token,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">epnum,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">banks&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>Value:</b><div class="fragment"><pre class="fragment"><a class="code" href="../../d3/dfe/a00025.html#b669385ecb2cb74e6d17a0bc671ec1aa">MACROS</a>{ Pipe_ConfigurePipe_P(num, size,   \
                                                                              ((type &lt;&lt; PTYPE0) | token | ((epnum &amp; <a class="code" href="../../d0/d89/a00071.html#f792d5d32653e0e7dac1103701636162">PIPE_EPNUM_MASK</a>) &lt;&lt; PEPNUM0)),   \
                                                                              banks); }<a class="code" href="../../d3/dfe/a00025.html#0b4041b3602c0924a8c61c7d8231c801">MACROE</a>
</pre></div>Configures the specified pipe number with the given pipe type, token, target endpoint number in the attached device, bank size and banking mode. Pipes should be allocated in ascending order by their address in the device (i.e. pipe 1 should be configured before pipe 2 and so on).<p>
The pipe type may be one of the EP_TYPE_* macros listed in <a class="el" href="../../da/d24/a00068.html">LowLevel.h</a>, the token may be one of the PIPE_TOKEN_* masks.<p>
The bank size must indicate the maximum packet size that the pipe can handle. Different pipe numbers can handle different maximum packet sizes - refer to the chosen USB AVR's datasheet to determine the maximum bank size for each pipe.<p>
The banking mode may be either PIPE_BANK_SINGLE or PIPE_BANK_DOUBLE.<p>
The success of this routine can be determined via the <a class="el" href="../../d0/d89/a00071.html#55d35cf0e4582c79d4da5112d1b22d7d">Pipe_IsConfigured()</a> macro. A newly configured pipe is frozen by default, and must be unfrozen before use via the <a class="el" href="../../d0/d89/a00071.html#9ef14dd97b9c5a69089e7e59aa5e4485">Pipe_Unfreeze()</a> macro.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This routine will select the specified pipe, and the pipe will remain selected once the routine completes regardless of if the pipe configuration succeeds. </dd></dl>

</div>
</div><p>
<a class="anchor" name="8114af361d1f52cc6e47447c9484ae98"></a><!-- doxytag: member="Pipe.h::PIPE_CONTROLPIPE" ref="8114af361d1f52cc6e47447c9484ae98" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PIPE_CONTROLPIPE&nbsp;&nbsp;&nbsp;0          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Pipe address for the default control pipe, which always resides in address 0. This is defined for convenience to give more readable code when used with the pipe macros. 
</div>
</div><p>
<a class="anchor" name="0dc275b75a1bccc1b51dd78ef1485e2e"></a><!-- doxytag: member="Pipe.h::PIPE_CONTROLPIPE_DEFAULT_SIZE" ref="0dc275b75a1bccc1b51dd78ef1485e2e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PIPE_CONTROLPIPE_DEFAULT_SIZE&nbsp;&nbsp;&nbsp;8          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Default size of the default control pipe's bank, until altered by the Endpoint0Size value in the device descriptor of the attached device. 
</div>
</div><p>
<a class="anchor" name="f79d7cbfe6295a894303f15681f75b08"></a><!-- doxytag: member="Pipe.h::Pipe_DisablePipe" ref="f79d7cbfe6295a894303f15681f75b08" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Pipe_DisablePipe          </td>
          <td>(</td>
&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;MACROS{ UPCONX  &amp;= ~(1 &lt;&lt; PEN);                                 }MACROE</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Disables the currently selected pipe so that data cannot be sent and received through it to and from an attached device. 
</div>
</div><p>
<a class="anchor" name="521da7ce84920dfd4a56568d4876bedd"></a><!-- doxytag: member="Pipe.h::Pipe_EnablePipe" ref="521da7ce84920dfd4a56568d4876bedd" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Pipe_EnablePipe          </td>
          <td>(</td>
&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;MACROS{ UPCONX  |=  (1 &lt;&lt; PEN);                                 }MACROE</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Enables the currently selected pipe so that data can be sent and received through it to and from an attached device.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>Pipes must first be configured properly rather than just being enabled via the <a class="el" href="../../d0/d89/a00071.html#7440ba6076dc942cbbee1ee4cf60db9b">Pipe_ConfigurePipe()</a> macro, which calls <a class="el" href="../../d0/d89/a00071.html#521da7ce84920dfd4a56568d4876bedd">Pipe_EnablePipe()</a> automatically. </dd></dl>

</div>
</div><p>
<a class="anchor" name="f792d5d32653e0e7dac1103701636162"></a><!-- doxytag: member="Pipe.h::PIPE_EPNUM_MASK" ref="f792d5d32653e0e7dac1103701636162" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PIPE_EPNUM_MASK&nbsp;&nbsp;&nbsp;0x07          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Endpoint number mask, for masking against endpoint addresses to retrieve the endpoint's numerical address in the attached device. 
</div>
</div><p>
<a class="anchor" name="52e4b610427b58ec8be83efcd074a028"></a><!-- doxytag: member="Pipe.h::PIPE_EPSIZE_MASK" ref="52e4b610427b58ec8be83efcd074a028" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PIPE_EPSIZE_MASK&nbsp;&nbsp;&nbsp;0x7FF          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Endpoint bank size mask, for masking against endpoint addresses to retrieve the endpoint's bank size in the attached device. 
</div>
</div><p>
<a class="anchor" name="523291f171ce8bbcad293302c702fff1"></a><!-- doxytag: member="Pipe.h::PIPE_ERRORFLAG_CRC16" ref="523291f171ce8bbcad293302c702fff1" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PIPE_ERRORFLAG_CRC16&nbsp;&nbsp;&nbsp;(1 &lt;&lt; 4)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Mask for <a class="el" href="../../d0/d89/a00071.html#8d68ec1831a407f8f19ebab1ec990708">Pipe_GetErrorFlags()</a>, indicating that a CRC error occurred in the pipe on the received data. 
</div>
</div><p>
<a class="anchor" name="69a45a7966eea73ea92d663b68748abd"></a><!-- doxytag: member="Pipe.h::PIPE_ERRORFLAG_DATAPID" ref="69a45a7966eea73ea92d663b68748abd" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PIPE_ERRORFLAG_DATAPID&nbsp;&nbsp;&nbsp;(1 &lt;&lt; 1)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Mask for <a class="el" href="../../d0/d89/a00071.html#8d68ec1831a407f8f19ebab1ec990708">Pipe_GetErrorFlags()</a>, indicating that a hardware data PID error occurred in the pipe. 
</div>
</div><p>
<a class="anchor" name="5b587ec7e9f0fc14d601bc6f9472bfdc"></a><!-- doxytag: member="Pipe.h::PIPE_ERRORFLAG_DATATGL" ref="5b587ec7e9f0fc14d601bc6f9472bfdc" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PIPE_ERRORFLAG_DATATGL&nbsp;&nbsp;&nbsp;(1 &lt;&lt; 0)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Mask for <a class="el" href="../../d0/d89/a00071.html#8d68ec1831a407f8f19ebab1ec990708">Pipe_GetErrorFlags()</a>, indicating that a hardware data toggle error occurred in the pipe. 
</div>
</div><p>
<a class="anchor" name="6758ca70b0917fb4076a8d4d2f6dd3f4"></a><!-- doxytag: member="Pipe.h::PIPE_ERRORFLAG_PID" ref="6758ca70b0917fb4076a8d4d2f6dd3f4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PIPE_ERRORFLAG_PID&nbsp;&nbsp;&nbsp;(1 &lt;&lt; 2)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Mask for <a class="el" href="../../d0/d89/a00071.html#8d68ec1831a407f8f19ebab1ec990708">Pipe_GetErrorFlags()</a>, indicating that a hardware PID error occurred in the pipe. 
</div>
</div><p>
<a class="anchor" name="5ba4ba74769293d65b32109e50a9e2d4"></a><!-- doxytag: member="Pipe.h::PIPE_ERRORFLAG_TIMEOUT" ref="5ba4ba74769293d65b32109e50a9e2d4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PIPE_ERRORFLAG_TIMEOUT&nbsp;&nbsp;&nbsp;(1 &lt;&lt; 3)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Mask for <a class="el" href="../../d0/d89/a00071.html#8d68ec1831a407f8f19ebab1ec990708">Pipe_GetErrorFlags()</a>, indicating that a hardware timeout error occurred in the pipe. 
</div>
</div><p>
<a class="anchor" name="7811fe4fbee7d93d7c09ac2c1d7e3408"></a><!-- doxytag: member="Pipe.h::Pipe_Freeze" ref="7811fe4fbee7d93d7c09ac2c1d7e3408" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Pipe_Freeze          </td>
          <td>(</td>
&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;MACROS{ UPCONX  |=  (1 &lt;&lt; PFREEZE);                             }MACROE</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Freezes the pipe, preventing it from communicating with an attached device. 
</div>
</div><p>
<a class="anchor" name="c135a6afb58a6675da7e82a0e6586be8"></a><!-- doxytag: member="Pipe.h::Pipe_GetCurrentPipe" ref="c135a6afb58a6675da7e82a0e6586be8" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Pipe_GetCurrentPipe          </td>
          <td>(</td>
&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;(UPNUM   &amp;   PIPE_PIPENUM_MASK)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns the pipe address of the currently selected pipe. This is typically used to save the currently selected pipe number so that it can be restored after another pipe has been manipulated. 
</div>
</div><p>
<a class="anchor" name="8d68ec1831a407f8f19ebab1ec990708"></a><!-- doxytag: member="Pipe.h::Pipe_GetErrorFlags" ref="8d68ec1831a407f8f19ebab1ec990708" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Pipe_GetErrorFlags          </td>
          <td>(</td>
&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;UPERRX</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a mask of the hardware error flags which have occured on the currently selected pipe. This value can then be masked against the PIPE_ERRORFLAG_* masks to determine what error has occurred. 
</div>
</div><p>
<a class="anchor" name="0ff2442c444be0dc9b539d03498d4051"></a><!-- doxytag: member="Pipe.h::Pipe_GetPipeInterrupts" ref="0ff2442c444be0dc9b539d03498d4051" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Pipe_GetPipeInterrupts          </td>
          <td>(</td>
&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;UPINT</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns a mask indicating which pipe's interrupt periods have elapsed, indicating that the pipe should be serviced. 
</div>
</div><p>
<a class="anchor" name="69165c3df4e014e158454a0b1c9f57d3"></a><!-- doxytag: member="Pipe.h::Pipe_HasPipeInterrupted" ref="69165c3df4e014e158454a0b1c9f57d3" args="(n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Pipe_HasPipeInterrupted          </td>
          <td>(</td>
          <td class="paramtype">n&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;((UPINT   &amp;   (1 &lt;&lt; n)) ? true : false)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if the specified pipe's interrupt period has elapsed, false otherwise. 
</div>
</div><p>
<a class="anchor" name="7239175cf7b3de1f7286b6879c892974"></a><!-- doxytag: member="Pipe.h::Pipe_Ignore_Byte" ref="7239175cf7b3de1f7286b6879c892974" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Pipe_Ignore_Byte          </td>
          <td>(</td>
&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;Pipe_Discard_Byte()</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Alias for <a class="el" href="../../d0/d89/a00071.html#e144e7739a66f9dbb1747d168ae20d58">Pipe_Discard_Byte()</a>. 
</div>
</div><p>
<a class="anchor" name="3e88f26f43087f20440787bd13cb0004"></a><!-- doxytag: member="Pipe.h::Pipe_Ignore_DWord" ref="3e88f26f43087f20440787bd13cb0004" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void Pipe_Ignore_DWord          </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;Pipe_Discard_DWord()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Discards four bytes from the currently selected pipe's bank, for OUT direction pipes.<p>
Alias for Pipe_Discard_DWord(). 
</div>
</div><p>
<a class="anchor" name="a6ede08012fd53a072fcbf57a29ac9d9"></a><!-- doxytag: member="Pipe.h::Pipe_Ignore_Word" ref="a6ede08012fd53a072fcbf57a29ac9d9" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void Pipe_Ignore_Word          </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;Pipe_Discard_Word()<code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Discards two bytes from the currently selected pipe's bank, for OUT direction pipes.<p>
Alias for Pipe_Discard_Word(). 
</div>
</div><p>
<a class="anchor" name="f5a17f07615300c63c2a3ace1282223f"></a><!-- doxytag: member="Pipe.h::PIPE_INT_ERROR" ref="f5a17f07615300c63c2a3ace1282223f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PIPE_INT_ERROR&nbsp;&nbsp;&nbsp;UPIENX, (1 &lt;&lt; PERRE), UPINTX, (1 &lt;&lt; PERRI)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Interrupt definition for the pipe error interrupt. Should be used with the USB_INT_* macros located in <a class="el" href="../../db/ddf/a00088.html">USBInterrupt.h</a>.<p>
This interrupt will fire if enabled on a particular pipe if an error occurs on that pipe, such as a CRC mismatch error.<p>
This interrupt must be enabled on *each* pipe which requires it (after the pipe is selected), and will fire the common pipe interrupt vector.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="../../db/ddf/a00088.html#30ff12c6e54e6c5b8a2062b665c69b9f">ENDPOINT_PIPE_vect</a> for more information on the common pipe and endpoint interrupt vector.<p>
<a class="el" href="../../d0/d89/a00071.html#8d68ec1831a407f8f19ebab1ec990708">Pipe_GetErrorFlags()</a> for more information on the pipe errors. </dd></dl>

</div>
</div><p>
<a class="anchor" name="976e9458f1d438d081e4f4db9e30c88e"></a><!-- doxytag: member="Pipe.h::PIPE_INT_IN" ref="976e9458f1d438d081e4f4db9e30c88e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PIPE_INT_IN&nbsp;&nbsp;&nbsp;UPIENX, (1 &lt;&lt; RXINE) , UPINTX, (1 &lt;&lt; RXINI)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Interrupt definition for the pipe IN interrupt (for INTERRUPT type pipes). Should be used with the USB_INT_* macros located in <a class="el" href="../../db/ddf/a00088.html">USBInterrupt.h</a>.<p>
This interrupt will fire if enabled on an INTERRUPT type pipe if the pipe interrupt period has elapsed and the pipe is ready for the next packet from the attached device to be read out from its FIFO buffer (if received).<p>
This interrupt must be enabled on *each* pipe which requires it (after the pipe is selected), and will fire the common pipe interrupt vector.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="../../db/ddf/a00088.html#30ff12c6e54e6c5b8a2062b665c69b9f">ENDPOINT_PIPE_vect</a> for more information on the common pipe and endpoint interrupt vector. </dd></dl>

</div>
</div><p>
<a class="anchor" name="d6a545d297025b1d83c986a9859e7c58"></a><!-- doxytag: member="Pipe.h::PIPE_INT_NAK" ref="d6a545d297025b1d83c986a9859e7c58" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PIPE_INT_NAK&nbsp;&nbsp;&nbsp;UPIENX, (1 &lt;&lt; NAKEDE), UPINTX, (1 &lt;&lt; NAKEDI)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Interrupt definition for the pipe NAK received interrupt. Should be used with the USB_INT_* macros located in <a class="el" href="../../db/ddf/a00088.html">USBInterrupt.h</a>.<p>
This interrupt will fire if enabled on a particular pipe if an attached device returns a NAK in response to a sent packet.<p>
This interrupt must be enabled on *each* pipe which requires it (after the pipe is selected), and will fire the common pipe interrupt vector.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="../../db/ddf/a00088.html#30ff12c6e54e6c5b8a2062b665c69b9f">ENDPOINT_PIPE_vect</a> for more information on the common pipe and endpoint interrupt vector.<p>
<a class="el" href="../../d0/d89/a00071.html#fc7477a30fe7f8c8411af1d4a1f293e0">Pipe_IsNAKReceived()</a> for more information on pipe NAKs. </dd></dl>

</div>
</div><p>
<a class="anchor" name="87d1066bebfbbb07272c8e249f440718"></a><!-- doxytag: member="Pipe.h::PIPE_INT_OUT" ref="87d1066bebfbbb07272c8e249f440718" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PIPE_INT_OUT&nbsp;&nbsp;&nbsp;UPIENX, (1 &lt;&lt; TXOUTE), UPINTX, (1 &lt;&lt; TXOUTI)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Interrupt definition for the pipe OUT interrupt (for INTERRUPT type pipes). Should be used with the USB_INT_* macros located in <a class="el" href="../../db/ddf/a00088.html">USBInterrupt.h</a>.<p>
This interrupt will fire if enabled on an INTERRUPT type endpoint if a the pipe interrupt period has elapsed and the pipe is ready for a packet to be written to the pipe's FIFO buffer and sent to the attached device (if required).<p>
This interrupt must be enabled on *each* pipe which requires it (after the pipe is selected), and will fire the common pipe interrupt vector.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="../../db/ddf/a00088.html#30ff12c6e54e6c5b8a2062b665c69b9f">ENDPOINT_PIPE_vect</a> for more information on the common pipe and endpoint interrupt vector. </dd></dl>

</div>
</div><p>
<a class="anchor" name="4d98daa30c1d0b57af528edd82edd358"></a><!-- doxytag: member="Pipe.h::PIPE_INT_SETUP" ref="4d98daa30c1d0b57af528edd82edd358" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PIPE_INT_SETUP&nbsp;&nbsp;&nbsp;UPIENX, (1 &lt;&lt; TXSTPE) , UPINTX, (1 &lt;&lt; TXSTPI)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Interrupt definition for the pipe SETUP bank ready interrupt (for CONTROL type pipes). Should be used with the USB_INT_* macros located in <a class="el" href="../../db/ddf/a00088.html">USBInterrupt.h</a>.<p>
This interrupt will fire if enabled on an CONTROL type pipe when the pipe is ready for a new control request.<p>
This interrupt must be enabled on *each* pipe which requires it (after the pipe is selected), and will fire the common pipe interrupt vector.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="../../db/ddf/a00088.html#30ff12c6e54e6c5b8a2062b665c69b9f">ENDPOINT_PIPE_vect</a> for more information on the common pipe and endpoint interrupt vector. </dd></dl>

</div>
</div><p>
<a class="anchor" name="64d01bc3bc4dc2e3dccd74a70782e768"></a><!-- doxytag: member="Pipe.h::PIPE_INT_STALL" ref="64d01bc3bc4dc2e3dccd74a70782e768" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PIPE_INT_STALL&nbsp;&nbsp;&nbsp;UPIENX, (1 &lt;&lt; RXSTALLE), UPINTX, (1 &lt;&lt; RXSTALLI)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Interrupt definition for the pipe STALL received interrupt. Should be used with the USB_INT_* macros located in <a class="el" href="../../db/ddf/a00088.html">USBInterrupt.h</a>.<p>
This interrupt will fire if enabled on a particular pipe if an attached device returns a STALL on the currently selected pipe. This will also fire if the pipe is an isochronous pipe and a CRC error occurs.<p>
This interrupt must be enabled on *each* pipe which requires it (after the pipe is selected), and will fire the common pipe interrupt vector.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="../../db/ddf/a00088.html#30ff12c6e54e6c5b8a2062b665c69b9f">ENDPOINT_PIPE_vect</a> for more information on the common pipe and endpoint interrupt vector. </dd></dl>

</div>
</div><p>
<a class="anchor" name="55d35cf0e4582c79d4da5112d1b22d7d"></a><!-- doxytag: member="Pipe.h::Pipe_IsConfigured" ref="55d35cf0e4582c79d4da5112d1b22d7d" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Pipe_IsConfigured          </td>
          <td>(</td>
&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;((UPSTAX  &amp; (1 &lt;&lt; CFGOK)) ? true : false)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if the currently selected pipe is configured, false otherwise. 
</div>
</div><p>
<a class="anchor" name="4c4f9dd8698d2c60bb7da0968ee11720"></a><!-- doxytag: member="Pipe.h::Pipe_IsEnabled" ref="4c4f9dd8698d2c60bb7da0968ee11720" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Pipe_IsEnabled          </td>
          <td>(</td>
&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;((UPCONX  &amp;   (1 &lt;&lt; PEN)) ? true : false)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if the currently selected pipe is enabled, false otherwise. 
</div>
</div><p>
<a class="anchor" name="eefd3c22c8671942ad0b024564210d58"></a><!-- doxytag: member="Pipe.h::Pipe_IsError" ref="eefd3c22c8671942ad0b024564210d58" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Pipe_IsError          </td>
          <td>(</td>
&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;((UPINTX  &amp;   (1 &lt;&lt; PERRI)) ? true : false)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if the master pipe error flag is set for the currently selected pipe, indicating that some sort of hardware error has occurred on the pipe.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="../../d0/d89/a00071.html#8d68ec1831a407f8f19ebab1ec990708">Pipe_GetErrorFlags()</a> macro for information on retreiving the exact error flag. </dd></dl>

</div>
</div><p>
<a class="anchor" name="fc7477a30fe7f8c8411af1d4a1f293e0"></a><!-- doxytag: member="Pipe.h::Pipe_IsNAKReceived" ref="fc7477a30fe7f8c8411af1d4a1f293e0" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Pipe_IsNAKReceived          </td>
          <td>(</td>
&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;((UPINTX &amp; (1 &lt;&lt; NAKEDI)) ? true : false)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if the device sent a NAK (Negative Acknowedge) in response to the last sent packet on the currently selected pipe. This ocurrs when the host sends a packet to the device, but the device is not currently ready to handle the packet (i.e. its endpoint banks are full). Once a NAK has been received, it must be cleard using <a class="el" href="../../d0/d89/a00071.html#aea8042b8877c065abf85e2893dd1228">Pipe_ClearNAKReceived()</a> before the previous (or any other) packet can be re-sent. 
</div>
</div><p>
<a class="anchor" name="6c863fa464d1fab07c7d864cad5b2fc7"></a><!-- doxytag: member="Pipe.h::Pipe_IsSetupINReceived" ref="6c863fa464d1fab07c7d864cad5b2fc7" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Pipe_IsSetupINReceived          </td>
          <td>(</td>
&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;((UPINTX  &amp;   (1 &lt;&lt; RXINI)) ? true : false)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if an IN request has been received on the currently selected CONTROL type pipe, false otherwise. 
</div>
</div><p>
<a class="anchor" name="75cf698a5511261ebb434bb77f11a345"></a><!-- doxytag: member="Pipe.h::Pipe_IsSetupOUTReady" ref="75cf698a5511261ebb434bb77f11a345" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Pipe_IsSetupOUTReady          </td>
          <td>(</td>
&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;((UPINTX  &amp;   (1 &lt;&lt; TXOUTI)) ? true : false)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if the currently selected CONTROL type pipe is ready to send an OUT request, false otherwise. 
</div>
</div><p>
<a class="anchor" name="9c9c9ce726ba81441b84d1ea3ba9d3c5"></a><!-- doxytag: member="Pipe.h::Pipe_IsSetupSent" ref="9c9c9ce726ba81441b84d1ea3ba9d3c5" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Pipe_IsSetupSent          </td>
          <td>(</td>
&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;((UPINTX  &amp;   (1 &lt;&lt; TXSTPI)) ? true : false)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if no SETUP request is currently being sent to the attached device, false otherwise. 
</div>
</div><p>
<a class="anchor" name="e2a5bff38979c9ee712102061e9c7ccd"></a><!-- doxytag: member="Pipe.h::Pipe_IsStalled" ref="e2a5bff38979c9ee712102061e9c7ccd" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Pipe_IsStalled          </td>
          <td>(</td>
&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;((UPINTX  &amp;   (1 &lt;&lt; RXSTALLI)) ? true : false)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if the currently selected pipe has been stalled by the attached device, false otherwise. 
</div>
</div><p>
<a class="anchor" name="6fbf2b826d418d254807eb6fac814ca2"></a><!-- doxytag: member="Pipe.h::PIPE_MAX_PIPES" ref="6fbf2b826d418d254807eb6fac814ca2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PIPE_MAX_PIPES&nbsp;&nbsp;&nbsp;7          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Total number of pipes (including the default control pipe at address 0) which may be used in the device. Different USB AVR models support different amounts of pipes, this value reflects the maximum number of pipes for the currently selected AVR model. 
</div>
</div><p>
<a class="anchor" name="ab4f0d06a298c058d074511c4d22dede"></a><!-- doxytag: member="Pipe.h::PIPE_MAX_SIZE" ref="ab4f0d06a298c058d074511c4d22dede" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PIPE_MAX_SIZE&nbsp;&nbsp;&nbsp;256          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Size in bytes of the largest pipe bank size possible in the device. Not all banks on each AVR model supports the largest bank size possible on the device; different pipe numbers support different maximum bank sizes. This value reflects the largest possible bank of any pipe on the currently selected USB AVR model. 
</div>
</div><p>
<a class="anchor" name="d7d98398d5e1509886cc458ba99cbff8"></a><!-- doxytag: member="Pipe.h::PIPE_PIPENUM_MASK" ref="d7d98398d5e1509886cc458ba99cbff8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PIPE_PIPENUM_MASK&nbsp;&nbsp;&nbsp;0x07          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Pipe number mask, for masking against pipe addresses to retrieve the pipe's numerical address in the device. 
</div>
</div><p>
<a class="anchor" name="a5d2ba4e45678384a146098faa289b4f"></a><!-- doxytag: member="Pipe.h::Pipe_Read_DWord" ref="a5d2ba4e45678384a146098faa289b4f" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Pipe_Read_DWord          </td>
          <td>(</td>
&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;Pipe_Read_DWord_LE()</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Alias for <a class="el" href="../../d0/d89/a00071.html#15cb7c4e354a3cece0d477ade632838d">Pipe_Read_DWord_LE()</a>. By default USB transfers use little endian format, thus the command with no endianness specifier indicates little endian mode. 
</div>
</div><p>
<a class="anchor" name="72f771b62120aeb8c5d663d38f733fa0"></a><!-- doxytag: member="Pipe.h::Pipe_Read_Stream" ref="72f771b62120aeb8c5d663d38f733fa0" args="(Buffer, Length, Callback)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Pipe_Read_Stream          </td>
          <td>(</td>
          <td class="paramtype">Buffer,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Length,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Callback&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;Pipe_Read_Stream_LE(Buffer, Length, Callback)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Alias for <a class="el" href="../../d0/d89/a00071.html#49a2264c02c6f6eb6471a3cce6e1423f">Pipe_Read_Stream_LE()</a>. By default USB transfers use little endian format, thus the command with no endianness specifier indicates little endian mode. 
</div>
</div><p>
<a class="anchor" name="d5622633568640ac4cd8dd60f2907250"></a><!-- doxytag: member="Pipe.h::Pipe_Read_Word" ref="d5622633568640ac4cd8dd60f2907250" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Pipe_Read_Word          </td>
          <td>(</td>
&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;Pipe_Read_Word_LE()</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Alias for <a class="el" href="../../d0/d89/a00071.html#0b0926d50ccf4ef5af1af2bc448ee088">Pipe_Read_Word_LE()</a>. By default USB transfers use little endian format, thus the command with no endianness specifier indicates little endian mode. 
</div>
</div><p>
<a class="anchor" name="5cce6692d5697e5fc9cb47c0e916dde4"></a><!-- doxytag: member="Pipe.h::Pipe_ReadWriteAllowed" ref="5cce6692d5697e5fc9cb47c0e916dde4" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Pipe_ReadWriteAllowed          </td>
          <td>(</td>
&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;((UPINTX  &amp; (1 &lt;&lt; RWAL)) ? true : false)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Returns true if the currently selected pipe may be read from (if data is waiting in the pipe bank and the pipe is an IN direction, or if the bank is not yet full if the pipe is an OUT direction). This function will return false if an error has occured in the pipe, or if the pipe is an IN direction and no packet has been received, or if the pipe is an OUT direction and the pipe bank is full. 
</div>
</div><p>
<a class="anchor" name="aa5c54e51f9c0afab134d4aca9a9ab5d"></a><!-- doxytag: member="Pipe.h::Pipe_ResetPipe" ref="aa5c54e51f9c0afab134d4aca9a9ab5d" args="(pipenum)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Pipe_ResetPipe          </td>
          <td>(</td>
          <td class="paramtype">pipenum&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;MACROS{ UPRST    =  (1 &lt;&lt; pipenum); UPRST = 0;                  }MACROE</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Resets the desired pipe, including the pipe banks and flags. 
</div>
</div><p>
<a class="anchor" name="bed265b616eb42f47825f03c8013c2e7"></a><!-- doxytag: member="Pipe.h::Pipe_SelectPipe" ref="bed265b616eb42f47825f03c8013c2e7" args="(pipenum)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Pipe_SelectPipe          </td>
          <td>(</td>
          <td class="paramtype">pipenum&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;MACROS{ UPNUM    =  pipenum;                                    }MACROE</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Selects the given pipe number. Any pipe operations which do not require the pipe number to be indicated will operate on the currently selected pipe. 
</div>
</div><p>
<a class="anchor" name="6a1ee11059a805a7d06e0d577a4bfddf"></a><!-- doxytag: member="Pipe.h::Pipe_SetFiniteINRequests" ref="6a1ee11059a805a7d06e0d577a4bfddf" args="(n)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Pipe_SetFiniteINRequests          </td>
          <td>(</td>
          <td class="paramtype">n&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;MACROS{ UPCONX  &amp;= ~(1 &lt;&lt; INMODE); UPINRQX = n;                 }MACROE</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Configures the currently selected pipe to only allow the specified number of IN requests to be accepted by the pipe before it is automatically frozen. 
</div>
</div><p>
<a class="anchor" name="861e95429a7247a658dc969fa7186a12"></a><!-- doxytag: member="Pipe.h::Pipe_SetInfiniteINRequests" ref="861e95429a7247a658dc969fa7186a12" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Pipe_SetInfiniteINRequests          </td>
          <td>(</td>
&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;MACROS{ UPCONX  |=  (1 &lt;&lt; INMODE);                              }MACROE</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Configures the currently selected pipe to allow for an unlimited number of IN requests. 
</div>
</div><p>
<a class="anchor" name="ddad91ae4c2bc3f4ed1ecd1121dc1168"></a><!-- doxytag: member="Pipe.h::Pipe_SetInterruptPeriod" ref="ddad91ae4c2bc3f4ed1ecd1121dc1168" args="(ms)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Pipe_SetInterruptPeriod          </td>
          <td>(</td>
          <td class="paramtype">ms&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;MACROS{ UPCFG2X  = ms;                                          }MACROE</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the period between interrupts for an INTERRUPT type pipe to a specified number of milliseconds. 
</div>
</div><p>
<a class="anchor" name="3965c03b31bb6f8312847cc4aeb1ff70"></a><!-- doxytag: member="Pipe.h::Pipe_SetToken" ref="3965c03b31bb6f8312847cc4aeb1ff70" args="(token)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Pipe_SetToken          </td>
          <td>(</td>
          <td class="paramtype">token&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;MACROS{ UPCFG0X  = ((UPCFG0X &amp; ~PIPE_TOKEN_MASK) | token);      }MACROE</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Sets the token for the currently selected endpoint to one of the tokens specified by the PIPE_TOKEN_* masks. This should only be used on CONTROL type endpoints, to allow for bidirectional transfer of data during control requests. 
</div>
</div><p>
<a class="anchor" name="aad74ddaafc14770bfd3902e202658ee"></a><!-- doxytag: member="Pipe.h::PIPE_TOKEN_IN" ref="aad74ddaafc14770bfd3902e202658ee" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PIPE_TOKEN_IN&nbsp;&nbsp;&nbsp;(0b01 &lt;&lt; PTOKEN0)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Token mask for <a class="el" href="../../d0/d89/a00071.html#7440ba6076dc942cbbee1ee4cf60db9b">Pipe_ConfigurePipe()</a>. This sets the pipe as a IN token (for non-CONTROL type pipes), indicating that the pipe data will flow from device to host. 
</div>
</div><p>
<a class="anchor" name="9d95c915c1f2fa07ecdcd1d08027ec40"></a><!-- doxytag: member="Pipe.h::PIPE_TOKEN_OUT" ref="9d95c915c1f2fa07ecdcd1d08027ec40" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PIPE_TOKEN_OUT&nbsp;&nbsp;&nbsp;(0b10 &lt;&lt; PTOKEN0)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Token mask for <a class="el" href="../../d0/d89/a00071.html#7440ba6076dc942cbbee1ee4cf60db9b">Pipe_ConfigurePipe()</a>. This sets the pipe as a IN token (for non-CONTROL type pipes), indicating that the pipe data will flow from host to device. 
</div>
</div><p>
<a class="anchor" name="23184c2580f8241fcc6c27c0a580706d"></a><!-- doxytag: member="Pipe.h::PIPE_TOKEN_SETUP" ref="23184c2580f8241fcc6c27c0a580706d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define PIPE_TOKEN_SETUP&nbsp;&nbsp;&nbsp;(0b00 &lt;&lt; PTOKEN0)          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Token mask for <a class="el" href="../../d0/d89/a00071.html#7440ba6076dc942cbbee1ee4cf60db9b">Pipe_ConfigurePipe()</a>. This sets the pipe as a SETUP token (for CONTROL type pipes), which will trigger a control request on the attached device when data is written to the pipe. 
</div>
</div><p>
<a class="anchor" name="9ef14dd97b9c5a69089e7e59aa5e4485"></a><!-- doxytag: member="Pipe.h::Pipe_Unfreeze" ref="9ef14dd97b9c5a69089e7e59aa5e4485" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Pipe_Unfreeze          </td>
          <td>(</td>
&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;MACROS{ UPCONX  &amp;= ~(1 &lt;&lt; PFREEZE);                             }MACROE</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Unfreezes the pipe, allowing it to communicate with an attached device. 
</div>
</div><p>
<a class="anchor" name="0d76013bb35096aff7765a9ea006e6b9"></a><!-- doxytag: member="Pipe.h::Pipe_Write_DWord" ref="0d76013bb35096aff7765a9ea006e6b9" args="(DWord)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Pipe_Write_DWord          </td>
          <td>(</td>
          <td class="paramtype">DWord&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;Pipe_Write_DWord_LE(DWord)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Alias for <a class="el" href="../../d0/d89/a00071.html#c4b3a34f538ea17df6e787138f32e3e6">Pipe_Write_DWord_LE()</a>. By default USB transfers use little endian format, thus the command with no endianness specifier indicates little endian mode. 
</div>
</div><p>
<a class="anchor" name="e18b1181009aaf36ba0470e93c052f24"></a><!-- doxytag: member="Pipe.h::Pipe_Write_Stream" ref="e18b1181009aaf36ba0470e93c052f24" args="(Buffer, Length, Callback)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Pipe_Write_Stream          </td>
          <td>(</td>
          <td class="paramtype">Buffer,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Length,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Callback&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;Pipe_Read_Stream_LE(Buffer, Length, Callback)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Alias for <a class="el" href="../../d0/d89/a00071.html#6c717328b7421d277ef5ec727779da8d">Pipe_Write_Stream_LE()</a>. By default USB transfers use little endian format, thus the command with no endianness specifier indicates little endian mode. 
</div>
</div><p>
<a class="anchor" name="f0eb734cd675fd9e3246a3dc62c11a16"></a><!-- doxytag: member="Pipe.h::Pipe_Write_Word" ref="f0eb734cd675fd9e3246a3dc62c11a16" args="(Word)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Pipe_Write_Word          </td>
          <td>(</td>
          <td class="paramtype">Word&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;Pipe_Write_Word_LE(Word)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Alias for <a class="el" href="../../d0/d89/a00071.html#2e6398dd044bc3c9f9eb1da4c6f76010">Pipe_Write_Word_LE()</a>. By default USB transfers use little endian format, thus the command with no endianness specifier indicates little endian mode. 
</div>
</div><p>
<hr><h2>Enumeration Type Documentation</h2>
<a class="anchor" name="b83460617bb7a5c928308a71307f237c"></a><!-- doxytag: member="Pipe.h::Pipe_Stream_RW_ErrorCodes_t" ref="b83460617bb7a5c928308a71307f237c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="../../d0/d89/a00071.html#b83460617bb7a5c928308a71307f237c">Pipe_Stream_RW_ErrorCodes_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Enum for the possible error return codes of the Pipe_*_Stream_* functions. <dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="b83460617bb7a5c928308a71307f237cce38ad06e68219be2cf49781efed2ea2"></a><!-- doxytag: member="PIPE_RWSTREAM_ERROR_NoError" ref="b83460617bb7a5c928308a71307f237cce38ad06e68219be2cf49781efed2ea2" args="" -->PIPE_RWSTREAM_ERROR_NoError</em>&nbsp;</td><td>
Command completed successfully, no error. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="b83460617bb7a5c928308a71307f237c03f7aa65e828a45baf1436b2b018a571"></a><!-- doxytag: member="PIPE_RWSTREAM_ERROR_PipeStalled" ref="b83460617bb7a5c928308a71307f237c03f7aa65e828a45baf1436b2b018a571" args="" -->PIPE_RWSTREAM_ERROR_PipeStalled</em>&nbsp;</td><td>
The device stalled the pipe during the transfer. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="b83460617bb7a5c928308a71307f237c549820a0ef14b68243af5bd9bc62f8c8"></a><!-- doxytag: member="PIPE_RWSTREAM_ERROR_DeviceDisconnected" ref="b83460617bb7a5c928308a71307f237c549820a0ef14b68243af5bd9bc62f8c8" args="" -->PIPE_RWSTREAM_ERROR_DeviceDisconnected</em>&nbsp;</td><td>
Device was disconnected from the host during the transfer. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="b83460617bb7a5c928308a71307f237c1ce48b47cb4e91de8c117ebe925c4b8d"></a><!-- doxytag: member="PIPE_RWSTREAM_ERROR_Timeout" ref="b83460617bb7a5c928308a71307f237c1ce48b47cb4e91de8c117ebe925c4b8d" args="" -->PIPE_RWSTREAM_ERROR_Timeout</em>&nbsp;</td><td>
The device failed to accept or send the next packet within the software timeout period set by the USB_STREAM_TIMEOUT_MS macro. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="b83460617bb7a5c928308a71307f237c5a1a76d2ebd66854bfc3abc1a9088480"></a><!-- doxytag: member="PIPE_RWSTREAM_ERROR_CallbackAborted" ref="b83460617bb7a5c928308a71307f237c5a1a76d2ebd66854bfc3abc1a9088480" args="" -->PIPE_RWSTREAM_ERROR_CallbackAborted</em>&nbsp;</td><td>
Indicates that the stream's callback function aborted the transfer early. </td></tr>
</table>
</dl>

</div>
</div><p>
<a class="anchor" name="fe05d0620e5882aced3764a691a11152"></a><!-- doxytag: member="Pipe.h::Pipe_WaitUntilReady_ErrorCodes_t" ref="fe05d0620e5882aced3764a691a11152" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="../../d0/d89/a00071.html#fe05d0620e5882aced3764a691a11152">Pipe_WaitUntilReady_ErrorCodes_t</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Enum for the possible error return codes of the Pipe_WaitUntilReady function <dl compact><dt><b>Enumerator: </b></dt><dd>
<table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" name="fe05d0620e5882aced3764a691a11152a76ab88bf27a7a9cf3cd489229e0ef8a"></a><!-- doxytag: member="PIPE_READYWAIT_NoError" ref="fe05d0620e5882aced3764a691a11152a76ab88bf27a7a9cf3cd489229e0ef8a" args="" -->PIPE_READYWAIT_NoError</em>&nbsp;</td><td>
Pipe ready for next packet, no error </td></tr>
<tr><td valign="top"><em><a class="anchor" name="fe05d0620e5882aced3764a691a1115233cd79b9ef1b7b85107ffafc28c32c81"></a><!-- doxytag: member="PIPE_READYWAIT_PipeStalled" ref="fe05d0620e5882aced3764a691a1115233cd79b9ef1b7b85107ffafc28c32c81" args="" -->PIPE_READYWAIT_PipeStalled</em>&nbsp;</td><td>
The device stalled the pipe while waiting. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="fe05d0620e5882aced3764a691a11152e4befd28416d0bb3b5f0c5fb8693b192"></a><!-- doxytag: member="PIPE_READYWAIT_DeviceDisconnected" ref="fe05d0620e5882aced3764a691a11152e4befd28416d0bb3b5f0c5fb8693b192" args="" -->PIPE_READYWAIT_DeviceDisconnected</em>&nbsp;</td><td>
Device was disconnected from the host while waiting. </td></tr>
<tr><td valign="top"><em><a class="anchor" name="fe05d0620e5882aced3764a691a111525e2a8c840c4a5756ebd426f935f18f20"></a><!-- doxytag: member="PIPE_READYWAIT_Timeout" ref="fe05d0620e5882aced3764a691a111525e2a8c840c4a5756ebd426f935f18f20" args="" -->PIPE_READYWAIT_Timeout</em>&nbsp;</td><td>
The device failed to accept or send the next packet within the software timeout period set by the USB_STREAM_TIMEOUT_MS macro. </td></tr>
</table>
</dl>

</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="e144e7739a66f9dbb1747d168ae20d58"></a><!-- doxytag: member="Pipe.h::Pipe_Discard_Byte" ref="e144e7739a66f9dbb1747d168ae20d58" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void Pipe_Discard_Byte           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Discards one byte from the currently selected pipe's bank, for OUT direction pipes. 
</div>
</div><p>
<a class="anchor" name="01b068e18872cf93db73777e6c93a775"></a><!-- doxytag: member="Pipe.h::Pipe_Discard_Stream" ref="01b068e18872cf93db73777e6c93a775" args="(uint16_t Length, uint8_t(*const Callback)(void))" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t Pipe_Discard_Stream           </td>
          <td>(</td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>Length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t(*)(void)&nbsp;</td>
          <td class="paramname"> <em>Callback</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reads and discards the given number of bytes from the pipe, discarding fully read packets from the host as needed. The last packet is not automatically discarded once the remaining bytes has been read; the user is responsible for manually discarding the last packet from the host via the <a class="el" href="../../d0/d89/a00071.html#432c04eb14903b47e9d5322fc4673360">Pipe_ClearCurrentBank()</a> macro. Between each USB packet, the given stream callback function is executed repeatedly until the next packet is ready, allowing for early aborts of stream transfers.<p>
The callback routine should be created using the <a class="el" href="../../d4/d63/a00082.html#d6e3a0d3480d20e11549313a8d26075c">STREAM_CALLBACK()</a> macro. If the token NO_STREAM_CALLBACKS is passed via the -D option to the compiler, stream callbacks are disabled and this function has the Callback parameter ommitted.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Length</em>&nbsp;</td><td>Number of bytes to send via the currently selected pipe. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Callback</em>&nbsp;</td><td>Name of a callback routine to call between sucessive USB packet transfers, NULL if no callback</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A value from the Pipe_Stream_RW_ErrorCodes_t enum. </dd></dl>

</div>
</div><p>
<a class="anchor" name="f97bf18ff71bb8d38a29e735add628c9"></a><!-- doxytag: member="Pipe.h::Pipe_Read_Byte" ref="f97bf18ff71bb8d38a29e735add628c9" args="(void) ATTR_WARN_UNUSED_RESULT" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static uint8_t Pipe_Read_Byte           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reads one byte from the currently selected pipe's bank, for OUT direction pipes. 
</div>
</div><p>
<a class="anchor" name="4a6d0b211f6294f80c98cf3199a1d66c"></a><!-- doxytag: member="Pipe.h::Pipe_Read_DWord_BE" ref="4a6d0b211f6294f80c98cf3199a1d66c" args="(void) ATTR_WARN_UNUSED_RESULT" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t Pipe_Read_DWord_BE           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reads four bytes from the currently selected pipe's bank in big endian format, for OUT direction pipes. 
</div>
</div><p>
<a class="anchor" name="15cb7c4e354a3cece0d477ade632838d"></a><!-- doxytag: member="Pipe.h::Pipe_Read_DWord_LE" ref="15cb7c4e354a3cece0d477ade632838d" args="(void) ATTR_WARN_UNUSED_RESULT" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static uint32_t Pipe_Read_DWord_LE           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reads four bytes from the currently selected pipe's bank in little endian format, for OUT direction pipes. 
</div>
</div><p>
<a class="anchor" name="b9c0b49a7853725c1570af6e0a55ca97"></a><!-- doxytag: member="Pipe.h::Pipe_Read_Stream_BE" ref="b9c0b49a7853725c1570af6e0a55ca97" args="(void *Buffer, uint16_t Length, uint8_t(*const Callback)(void)) ATTR_NON_NULL_PTR_ARG(1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t Pipe_Read_Stream_BE           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>Buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>Length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t(*)(void)&nbsp;</td>
          <td class="paramname"> <em>Callback</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reads the given number of bytes from the pipe into the given buffer in big endian, sending full packets to the device as needed. The last packet filled is not automatically sent; the user is responsible for manually sending the last written packet to the host via the <a class="el" href="../../d0/d89/a00071.html#432c04eb14903b47e9d5322fc4673360">Pipe_ClearCurrentBank()</a> macro. Between each USB packet, the given stream callback function is executed repeatedly until the next packet is ready, allowing for early aborts of stream transfers.<p>
The callback routine should be created using the <a class="el" href="../../d4/d63/a00082.html#d6e3a0d3480d20e11549313a8d26075c">STREAM_CALLBACK()</a> macro. If the token NO_STREAM_CALLBACKS is passed via the -D option to the compiler, stream callbacks are disabled and this function has the Callback parameter ommitted.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Buffer</em>&nbsp;</td><td>Pointer to the source data buffer to write to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Length</em>&nbsp;</td><td>Number of bytes to read for the currently selected pipe to read from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Callback</em>&nbsp;</td><td>Name of a callback routine to call between sucessive USB packet transfers, NULL if no callback</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A value from the Pipe_Stream_RW_ErrorCodes_t enum. </dd></dl>

</div>
</div><p>
<a class="anchor" name="49a2264c02c6f6eb6471a3cce6e1423f"></a><!-- doxytag: member="Pipe.h::Pipe_Read_Stream_LE" ref="49a2264c02c6f6eb6471a3cce6e1423f" args="(void *Buffer, uint16_t Length, uint8_t(*const Callback)(void)) ATTR_NON_NULL_PTR_ARG(1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t Pipe_Read_Stream_LE           </td>
          <td>(</td>
          <td class="paramtype">void *&nbsp;</td>
          <td class="paramname"> <em>Buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>Length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t(*)(void)&nbsp;</td>
          <td class="paramname"> <em>Callback</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reads the given number of bytes from the pipe into the given buffer in little endian, sending full packets to the device as needed. The last packet filled is not automatically sent; the user is responsible for manually sending the last written packet to the host via the <a class="el" href="../../d0/d89/a00071.html#432c04eb14903b47e9d5322fc4673360">Pipe_ClearCurrentBank()</a> macro. Between each USB packet, the given stream callback function is executed repeatedly until the next packet is ready, allowing for early aborts of stream transfers.<p>
The callback routine should be created using the <a class="el" href="../../d4/d63/a00082.html#d6e3a0d3480d20e11549313a8d26075c">STREAM_CALLBACK()</a> macro. If the token NO_STREAM_CALLBACKS is passed via the -D option to the compiler, stream callbacks are disabled and this function has the Callback parameter ommitted.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Buffer</em>&nbsp;</td><td>Pointer to the source data buffer to write to. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Length</em>&nbsp;</td><td>Number of bytes to read for the currently selected pipe to read from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Callback</em>&nbsp;</td><td>Name of a callback routine to call between sucessive USB packet transfers, NULL if no callback</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A value from the Pipe_Stream_RW_ErrorCodes_t enum. </dd></dl>

</div>
</div><p>
<a class="anchor" name="1b817b4e70ad368b1e5b3eef82703d55"></a><!-- doxytag: member="Pipe.h::Pipe_Read_Word_BE" ref="1b817b4e70ad368b1e5b3eef82703d55" args="(void) ATTR_WARN_UNUSED_RESULT" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static uint16_t Pipe_Read_Word_BE           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reads two bytes from the currently selected pipe's bank in big endian format, for OUT direction pipes. 
</div>
</div><p>
<a class="anchor" name="0b0926d50ccf4ef5af1af2bc448ee088"></a><!-- doxytag: member="Pipe.h::Pipe_Read_Word_LE" ref="0b0926d50ccf4ef5af1af2bc448ee088" args="(void) ATTR_WARN_UNUSED_RESULT" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static uint16_t Pipe_Read_Word_LE           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Reads two bytes from the currently selected pipe's bank in little endian format, for OUT direction pipes. 
</div>
</div><p>
<a class="anchor" name="cb9093cfd973aa4b51fff09cfaa53ba9"></a><!-- doxytag: member="Pipe.h::Pipe_WaitUntilReady" ref="cb9093cfd973aa4b51fff09cfaa53ba9" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t Pipe_WaitUntilReady           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Spinloops until the currently selected non-control pipe is ready for the next packed of data to be read or written to it.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This routine should not be called on CONTROL type pipes.</dd></dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A value from the Pipe_WaitUntilReady_ErrorCodes_t enum. </dd></dl>

</div>
</div><p>
<a class="anchor" name="40f86cc79768d0113c296378efe8bbcd"></a><!-- doxytag: member="Pipe.h::Pipe_Write_Byte" ref="40f86cc79768d0113c296378efe8bbcd" args="(const uint8_t Byte)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void Pipe_Write_Byte           </td>
          <td>(</td>
          <td class="paramtype">const uint8_t&nbsp;</td>
          <td class="paramname"> <em>Byte</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Writes one byte from the currently selected pipe's bank, for IN direction pipes. 
</div>
</div><p>
<a class="anchor" name="f575d5460ffe1ce56f20872f9daaa340"></a><!-- doxytag: member="Pipe.h::Pipe_Write_DWord_BE" ref="f575d5460ffe1ce56f20872f9daaa340" args="(const uint32_t DWord)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void Pipe_Write_DWord_BE           </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&nbsp;</td>
          <td class="paramname"> <em>DWord</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Writes four bytes to the currently selected pipe's bank in big endian format, for IN direction pipes. 
</div>
</div><p>
<a class="anchor" name="c4b3a34f538ea17df6e787138f32e3e6"></a><!-- doxytag: member="Pipe.h::Pipe_Write_DWord_LE" ref="c4b3a34f538ea17df6e787138f32e3e6" args="(const uint32_t DWord)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void Pipe_Write_DWord_LE           </td>
          <td>(</td>
          <td class="paramtype">const uint32_t&nbsp;</td>
          <td class="paramname"> <em>DWord</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Writes four bytes to the currently selected pipe's bank in little endian format, for IN direction pipes. 
</div>
</div><p>
<a class="anchor" name="63143341fde11dc535188184b6977e48"></a><!-- doxytag: member="Pipe.h::Pipe_Write_Stream_BE" ref="63143341fde11dc535188184b6977e48" args="(const void *Buffer, uint16_t Length, uint8_t(*const Callback)(void)) ATTR_NON_NULL_PTR_ARG(1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t Pipe_Write_Stream_BE           </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>Buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>Length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t(*)(void)&nbsp;</td>
          <td class="paramname"> <em>Callback</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Writes the given number of bytes to the pipe from the given buffer in big endian, sending full packets to the device as needed. The last packet filled is not automatically sent; the user is responsible for manually sending the last written packet to the host via the <a class="el" href="../../d0/d89/a00071.html#432c04eb14903b47e9d5322fc4673360">Pipe_ClearCurrentBank()</a> macro. Between each USB packet, the given stream callback function is executed repeatedly until the next packet is ready, allowing for early aborts of stream transfers.<p>
The callback routine should be created using the <a class="el" href="../../d4/d63/a00082.html#d6e3a0d3480d20e11549313a8d26075c">STREAM_CALLBACK()</a> macro. If the token NO_STREAM_CALLBACKS is passed via the -D option to the compiler, stream callbacks are disabled and this function has the Callback parameter ommitted.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Buffer</em>&nbsp;</td><td>Pointer to the source data buffer to read from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Length</em>&nbsp;</td><td>Number of bytes to read for the currently selected pipe into the buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Callback</em>&nbsp;</td><td>Name of a callback routine to call between sucessive USB packet transfers, NULL if no callback</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A value from the Pipe_Stream_RW_ErrorCodes_t enum. </dd></dl>

</div>
</div><p>
<a class="anchor" name="6c717328b7421d277ef5ec727779da8d"></a><!-- doxytag: member="Pipe.h::Pipe_Write_Stream_LE" ref="6c717328b7421d277ef5ec727779da8d" args="(const void *Buffer, uint16_t Length, uint8_t(*const Callback)(void)) ATTR_NON_NULL_PTR_ARG(1)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t Pipe_Write_Stream_LE           </td>
          <td>(</td>
          <td class="paramtype">const void *&nbsp;</td>
          <td class="paramname"> <em>Buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&nbsp;</td>
          <td class="paramname"> <em>Length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t(*)(void)&nbsp;</td>
          <td class="paramname"> <em>Callback</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Writes the given number of bytes to the pipe from the given buffer in little endian, sending full packets to the device as needed. The last packet filled is not automatically sent; the user is responsible for manually sending the last written packet to the host via the <a class="el" href="../../d0/d89/a00071.html#432c04eb14903b47e9d5322fc4673360">Pipe_ClearCurrentBank()</a> macro. Between each USB packet, the given stream callback function is executed repeatedly until the next packet is ready, allowing for early aborts of stream transfers.<p>
The callback routine should be created using the <a class="el" href="../../d4/d63/a00082.html#d6e3a0d3480d20e11549313a8d26075c">STREAM_CALLBACK()</a> macro. If the token NO_STREAM_CALLBACKS is passed via the -D option to the compiler, stream callbacks are disabled and this function has the Callback parameter ommitted.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>Buffer</em>&nbsp;</td><td>Pointer to the source data buffer to read from. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Length</em>&nbsp;</td><td>Number of bytes to read for the currently selected pipe into the buffer. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>Callback</em>&nbsp;</td><td>Name of a callback routine to call between sucessive USB packet transfers, NULL if no callback</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>A value from the Pipe_Stream_RW_ErrorCodes_t enum. </dd></dl>

</div>
</div><p>
<a class="anchor" name="11bcfcea2698991075d7c3db40f9cf89"></a><!-- doxytag: member="Pipe.h::Pipe_Write_Word_BE" ref="11bcfcea2698991075d7c3db40f9cf89" args="(const uint16_t Word)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void Pipe_Write_Word_BE           </td>
          <td>(</td>
          <td class="paramtype">const uint16_t&nbsp;</td>
          <td class="paramname"> <em>Word</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Writes two bytes to the currently selected pipe's bank in big endian format, for IN direction pipes. 
</div>
</div><p>
<a class="anchor" name="2e6398dd044bc3c9f9eb1da4c6f76010"></a><!-- doxytag: member="Pipe.h::Pipe_Write_Word_LE" ref="2e6398dd044bc3c9f9eb1da4c6f76010" args="(const uint16_t Word)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void Pipe_Write_Word_LE           </td>
          <td>(</td>
          <td class="paramtype">const uint16_t&nbsp;</td>
          <td class="paramname"> <em>Word</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Writes two bytes to the currently selected pipe's bank in little endian format, for IN direction pipes. 
</div>
</div><p>
<hr><h2>Variable Documentation</h2>
<a class="anchor" name="d76597acf13d471a30ff9785b94b01e2"></a><!-- doxytag: member="Pipe.h::USB_ControlPipeSize" ref="d76597acf13d471a30ff9785b94b01e2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t <a class="el" href="../../d0/d89/a00071.html#d76597acf13d471a30ff9785b94b01e2">USB_ControlPipeSize</a>          </td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Global indicating the maximum packet size of the default control pipe located at address 0 in the device. This value is set to the value indicated in the attached device's device descriptor once the USB interface is initialized into host mode and a device is attached to the USB bus.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This variable should be treated as read-only in the user application, and never manually changed in value. </dd></dl>

</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Thu Oct 2 18:01:18 2008 for MyUSB Library by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.5 </small></address>
</body>
</html>
