<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>MyUSB Library: Events.h File Reference</title>
<link href="../../doxygen.css" rel="stylesheet" type="text/css">
<link href="../../tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.5 -->
<script type="text/javascript">
<!--
function changeDisplayState (e){
  var num=this.id.replace(/[^[0-9]/g,'');
  var button=this.firstChild;
  var sectionDiv=document.getElementById('dynsection'+num);
  if (sectionDiv.style.display=='none'||sectionDiv.style.display==''){
    sectionDiv.style.display='block';
    button.src='../../open.gif';
  }else{
    sectionDiv.style.display='none';
    button.src='../../closed.gif';
  }
}
function initDynSections(){
  var divs=document.getElementsByTagName('div');
  var sectionCounter=1;
  for(var i=0;i<divs.length-1;i++){
    if(divs[i].className=='dynheader'&&divs[i+1].className=='dynsection'){
      var header=divs[i];
      var section=divs[i+1];
      var button=header.firstChild;
      if (button!='IMG'){
        divs[i].insertBefore(document.createTextNode(' '),divs[i].firstChild);
        button=document.createElement('img');
        divs[i].insertBefore(button,divs[i].firstChild);
      }
      header.style.cursor='pointer';
      header.onclick=changeDisplayState;
      header.id='dynheader'+sectionCounter;
      button.src='../../closed.gif';
      section.id='dynsection'+sectionCounter;
      section.style.display='none';
      section.style.marginLeft='14px';
      sectionCounter++;
    }
  }
}
window.onload = initDynSections;
-->
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="../../main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="../../pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="../../classes.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="../../files.html"><span>Files</span></a></li>
      <li><a href="../../dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div class="navpath"><a class="el" href="../../dir_2e1fbef791c6441b28631243cfb4eaa5.html">MyUSB</a>&nbsp;&raquo&nbsp;<a class="el" href="../../dir_88a6e91c5675e76375b47b277a58e3e8.html">Drivers</a>&nbsp;&raquo&nbsp;<a class="el" href="../../dir_cf4f163638ad68cd11bd930d84c7b552.html">USB</a>&nbsp;&raquo&nbsp;<a class="el" href="../../dir_b5c6f364768553a60d6eadc38ce533df.html">HighLevel</a>
  </div>
</div>
<div class="contents">
<h1>Events.h File Reference</h1><code>#include &lt;avr/io.h&gt;</code><br>
<code>#include &quot;<a class="el" href="../../d3/dfe/a00025.html">../../../Common/Common.h</a>&quot;</code><br>
<code>#include &quot;../LowLevel/USBMode.h&quot;</code><br>
<table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Defines</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db6/a00042.html#a8696c87c7bd42143f0526ad3d35f72f">RAISE_EVENT</a>(e,...)&nbsp;&nbsp;&nbsp;Event_ ## e (__VA_ARGS__)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db6/a00042.html#d267d1d51bbc1dd2f813fe624ac6f3c6">RAISES_EVENT</a>(e)&nbsp;&nbsp;&nbsp;HANDLES_EVENT(e)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db6/a00042.html#85a721b3b0b99dd8bd752f0bf5a9943d">EVENT_HANDLER</a>(e)&nbsp;&nbsp;&nbsp;void Event_ ## e e ## _P</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">#define&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db6/a00042.html#2d5205021878de599be19aab16bb9317">HANDLES_EVENT</a>(e)&nbsp;&nbsp;&nbsp;EVENT_HANDLER(e)</td></tr>

<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db6/a00042.html#253fc995008bf65680601da5deac9d00">USB_VBUSChange</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db6/a00042.html#edd44878daf24534278acb0a93fb279d">USB_VBUSConnect</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db6/a00042.html#3d08e81e10a9a4279918317df39c30b9">USB_VBUSDisconnect</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db6/a00042.html#a8030f3500c8942f2312cee175f1f297">USB_Connect</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db6/a00042.html#7775f1fb471022d0f6b94d3eee0fe8d0">USB_Disconnect</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db6/a00042.html#a78f34646aecb70b9631a32ad70a1d29">USB_PowerOnFail</a> (const uint8_t ErrorCode)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db6/a00042.html#b97c3ae10c0485db11aaad8103c546eb">USB_UIDChange</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db6/a00042.html#b99a3e845f74ff907bd027f044745fa9">USB_HostError</a> (const uint8_t ErrorCode)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db6/a00042.html#e5942b18ebf2a6e8f763e08f10f69c7d">USB_DeviceAttached</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db6/a00042.html#a5f0474c7ff1b22626bb015a2e195262">USB_DeviceUnattached</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db6/a00042.html#40f33cbf73bbd7c5c17767a1033d9908">USB_DeviceEnumerationFailed</a> (const uint8_t ErrorCode)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db6/a00042.html#58fe21d940b41af9467882a327de160c">USB_DeviceEnumerationComplete</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db6/a00042.html#4e4d33dcbef3545a413e1bea0afecbeb">USB_UnhandledControlPacket</a> (const uint8_t bRequest, const uint8_t bmRequestType)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db6/a00042.html#daa7bcde5465ae416e61465aa515e388">USB_ConfigurationChanged</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db6/a00042.html#87b4006411b630cc848d30b3e8a53e34">USB_Suspend</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db6/a00042.html#076f3794dcd3ff5b60ad10ea702424ca">USB_WakeUp</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db6/a00042.html#bfc0896707a9437a0c3b0ac611da59aa">USB_Reset</a> (void)</td></tr>

<tr><td class="memItemLeft" nowrap align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d5/db6/a00042.html#b29577a1062377b86bdab0352d26aeac">USB_DeviceError</a> (const uint8_t ErrorCode)</td></tr>

</table>
<hr><h2>Define Documentation</h2>
<a class="anchor" name="85a721b3b0b99dd8bd752f0bf5a9943d"></a><!-- doxytag: member="Events.h::EVENT_HANDLER" ref="85a721b3b0b99dd8bd752f0bf5a9943d" args="(e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EVENT_HANDLER          </td>
          <td>(</td>
          <td class="paramtype">e&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;void Event_ ## e e ## _P</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Defines an event handler for the given event. Event handlers should be short in length, as they may be raised from inside an ISR. The user application can react to each event as it sees fit, such as logging the event, indicating the change to the user or performing some other action.<p>
Only one event handler may be defined in any user project for each individual event. Events may or may not have parameters - for each event, refer to its documentation elsewhere in this module to determine the presense and purpose of any event parameters.<p>
Usage Example: <div class="fragment"><pre class="fragment">  <span class="comment">// Create an event handler for the USB_VBUSChange event</span>
  <a class="code" href="../../d5/db6/a00042.html#85a721b3b0b99dd8bd752f0bf5a9943d">EVENT_HANDLER</a>(<a class="code" href="../../d5/db6/a00042.html#253fc995008bf65680601da5deac9d00">USB_VBUSChange</a>)
  {
      <span class="comment">// Code to execute when the VBUS level changes</span>
  }
</pre></div><p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="../../d5/db6/a00042.html#2d5205021878de599be19aab16bb9317">HANDLES_EVENT()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="2d5205021878de599be19aab16bb9317"></a><!-- doxytag: member="Events.h::HANDLES_EVENT" ref="2d5205021878de599be19aab16bb9317" args="(e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define HANDLES_EVENT          </td>
          <td>(</td>
          <td class="paramtype">e&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;EVENT_HANDLER(e)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Indicates that a given module handles an event. This is the equivelent of putting the event function's prototype into the module, but in a cleaner way. Each event which may be handled via the EVENT_HANDLER macro in the module should have an accompanying HANDLES_EVENT prototype in the module's header file.<p>
Usage Examples: <div class="fragment"><pre class="fragment">  <span class="comment">// Module handles the USB_VBUSChange event</span>
  <a class="code" href="../../d5/db6/a00042.html#2d5205021878de599be19aab16bb9317">HANDLES_EVENT</a>(<a class="code" href="../../d5/db6/a00042.html#253fc995008bf65680601da5deac9d00">USB_VBUSChange</a>);

  <span class="comment">// Create the USB_VBUSChange event handler</span>
  <a class="code" href="../../d5/db6/a00042.html#85a721b3b0b99dd8bd752f0bf5a9943d">EVENT_HANDLER</a>(<a class="code" href="../../d5/db6/a00042.html#253fc995008bf65680601da5deac9d00">USB_VBUSChange</a>)
  {
      <span class="comment">// Event handler code here</span>
  }
</pre></div><p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="../../d5/db6/a00042.html#85a721b3b0b99dd8bd752f0bf5a9943d">EVENT_HANDLER()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="a8696c87c7bd42143f0526ad3d35f72f"></a><!-- doxytag: member="Events.h::RAISE_EVENT" ref="a8696c87c7bd42143f0526ad3d35f72f" args="(e,...)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RAISE_EVENT          </td>
          <td>(</td>
          <td class="paramtype">e,         <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"> <em>...</em>&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;Event_ ## e (__VA_ARGS__)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Library events module. This module contains macros and functions relating to the management of library events, which are small pieces of code similar to ISRs which are run when a given condition is met. Each event can be fired from multiple places in the user or library code, which may or may not be inside an ISR, thus each handler should be written to be as small and fast as possible to prevent possible problems.<p>
Events can be hooked by the user application using the <a class="el" href="../../d5/db6/a00042.html#85a721b3b0b99dd8bd752f0bf5a9943d">EVENT_HANDLER()</a> and <a class="el" href="../../d5/db6/a00042.html#2d5205021878de599be19aab16bb9317">HANDLES_EVENT()</a> macros. If an event with no associated handler is fired within the library, it by default fires an internal empty stub function. This is achieved through the use of the GCC compiler's "alias" attribute.<p>
Each event must only have one associated event handler, but can be raised by multiple sources. Raises a given event name, with the specified parameters. For events with no parameters the only argument to the macro is the event name, events with parameters list the parameter values after the name as a comma seperated list.<p>
When a given event is fired, its corresponding event handler code is executed.<p>
Usage Examples: <div class="fragment"><pre class="fragment">  <span class="comment">// Raise the USB_VBUSChange event, which takes no parameters</span>
  <a class="code" href="../../d5/db6/a00042.html#a8696c87c7bd42143f0526ad3d35f72f">RAISE_EVENT</a>(<a class="code" href="../../d5/db6/a00042.html#253fc995008bf65680601da5deac9d00">USB_VBUSChange</a>);

  <span class="comment">// Raise the USB_UnhandledControlPacket event which takes two parameters</span>
  <a class="code" href="../../d5/db6/a00042.html#a8696c87c7bd42143f0526ad3d35f72f">RAISE_EVENT</a>(<a class="code" href="../../d5/db6/a00042.html#4e4d33dcbef3545a413e1bea0afecbeb">USB_UnhandledControlPacket</a>, 0, 1);
</pre></div><p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="../../d5/db6/a00042.html#d267d1d51bbc1dd2f813fe624ac6f3c6">RAISES_EVENT()</a> </dd></dl>

</div>
</div><p>
<a class="anchor" name="d267d1d51bbc1dd2f813fe624ac6f3c6"></a><!-- doxytag: member="Events.h::RAISES_EVENT" ref="d267d1d51bbc1dd2f813fe624ac6f3c6" args="(e)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RAISES_EVENT          </td>
          <td>(</td>
          <td class="paramtype">e&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%">&nbsp;&nbsp;&nbsp;HANDLES_EVENT(e)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Indicates that a given module can raise a given event. This is the equivelent of putting the event function's prototype into the module, but in a cleaner way. Each event which may be fired via the RAISE_EVENT macro in the module should have an accompanying RAISES_EVENT prototype in the module's header file.<p>
Usage Examples: <div class="fragment"><pre class="fragment">  <span class="comment">// Module can raise the USB_VBUSChange event</span>
  <a class="code" href="../../d5/db6/a00042.html#d267d1d51bbc1dd2f813fe624ac6f3c6">RAISES_EVENT</a>(<a class="code" href="../../d5/db6/a00042.html#253fc995008bf65680601da5deac9d00">USB_VBUSChange</a>);

  <span class="comment">// ...</span>
  <span class="comment">// Inside a block of code in a function of the module, raise the USB_VBUSChange event</span>
  <a class="code" href="../../d5/db6/a00042.html#a8696c87c7bd42143f0526ad3d35f72f">RAISE_EVENT</a>(<a class="code" href="../../d5/db6/a00042.html#253fc995008bf65680601da5deac9d00">USB_VBUSChange</a>);
</pre></div><p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="../../d5/db6/a00042.html#a8696c87c7bd42143f0526ad3d35f72f">RAISE_EVENT()</a> </dd></dl>

</div>
</div><p>
<hr><h2>Function Documentation</h2>
<a class="anchor" name="daa7bcde5465ae416e61465aa515e388"></a><!-- doxytag: member="Events.h::USB_ConfigurationChanged" ref="daa7bcde5465ae416e61465aa515e388" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USB_ConfigurationChanged           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Event for USB configuration number changed. This event fires when a the USB host changes the selected configuration number while in device mode. This event should be hooked in device applications to create the endpoints and configure the device for the selected configuration.<p>
This event fires after the value of USB_ConfigurationNumber has been changed.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This event does not exist if the USB_HOST_ONLY token is supplied to the compiler (see <a class="el" href="../../da/d24/a00068.html">LowLevel.h</a> documentation). </dd></dl>

</div>
</div><p>
<a class="anchor" name="a8030f3500c8942f2312cee175f1f297"></a><!-- doxytag: member="Events.h::USB_Connect" ref="a8030f3500c8942f2312cee175f1f297" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USB_Connect           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Event for USB device connection. This event fires when the AVR is in USB host mode and a device has been attached (but not yet fully enumerated), or when in device mode and the device is connected to a host, beginning the enumeration process.<p>
When in device mode, this can be used to progmatically start the USB management task to reduce CPU usage.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="../../d9/dec/a00090.html">USBTask.h</a> for more information on the USB management task and reducing CPU usage. </dd></dl>

</div>
</div><p>
<a class="anchor" name="e5942b18ebf2a6e8f763e08f10f69c7d"></a><!-- doxytag: member="Events.h::USB_DeviceAttached" ref="e5942b18ebf2a6e8f763e08f10f69c7d" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USB_DeviceAttached           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Event for USB device attachment. This event fires when a the USB interface is in host mode, and a USB device has been connected to the USB interface. This is interrupt driven, thus fires before the standard USB_DeviceConnect event and so can be used to programatically start the USB management task to reduce CPU consumption.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This event only exists on USB AVR models which supports host mode.<p>
This event does not exist if the USB_DEVICE_ONLY token is supplied to the compiler (see <a class="el" href="../../da/d24/a00068.html">LowLevel.h</a> documentation).</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="../../d9/dec/a00090.html">USBTask.h</a> for more information on the USB management task and reducing CPU usage. </dd></dl>

</div>
</div><p>
<a class="anchor" name="58fe21d940b41af9467882a327de160c"></a><!-- doxytag: member="Events.h::USB_DeviceEnumerationComplete" ref="58fe21d940b41af9467882a327de160c" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USB_DeviceEnumerationComplete           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Event for USB device enumeration completion. This event fires when a the USB interface is in host mode and an attached USB device has been completely enumerated and is ready to be controlled by the user application, or when the library is in device mode, and the Host has finished enumerating the device. 
</div>
</div><p>
<a class="anchor" name="40f33cbf73bbd7c5c17767a1033d9908"></a><!-- doxytag: member="Events.h::USB_DeviceEnumerationFailed" ref="40f33cbf73bbd7c5c17767a1033d9908" args="(const uint8_t ErrorCode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USB_DeviceEnumerationFailed           </td>
          <td>(</td>
          <td class="paramtype">const uint8_t&nbsp;</td>
          <td class="paramname"> <em>ErrorCode</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Event for USB device enumeration failure. This event fires when a the USB interface is in host mode, and an attached USB device has failed to enumerate completely.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ErrorCode</em>&nbsp;</td><td>Error code indicating the failure reason, a value in USB_Host_EnumerationErrorCodes_t located in <a class="el" href="../../d4/dca/a00048.html">Host.h</a>.</td></tr>
  </table>
</dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This event only exists on USB AVR models which supports host mode.<p>
This event does not exist if the USB_DEVICE_ONLY token is supplied to the compiler (see <a class="el" href="../../da/d24/a00068.html">LowLevel.h</a> documentation). </dd></dl>

</div>
</div><p>
<a class="anchor" name="b29577a1062377b86bdab0352d26aeac"></a><!-- doxytag: member="Events.h::USB_DeviceError" ref="b29577a1062377b86bdab0352d26aeac" args="(const uint8_t ErrorCode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USB_DeviceError           </td>
          <td>(</td>
          <td class="paramtype">const uint8_t&nbsp;</td>
          <td class="paramname"> <em>ErrorCode</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Event for USB device mode error. This event fires when the USB interface is in device mode, and an error occurs which prevents it from operating normally.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ErrorCode</em>&nbsp;</td><td>Error code indicating the source of the error. One of the values in the USB_Device_ErrorCodes_t enum located in <a class="el" href="../../d4/d8c/a00035.html">Device.h</a>.</td></tr>
  </table>
</dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This event does not exist if the USB_HOST_ONLY token is supplied to the compiler (see <a class="el" href="../../da/d24/a00068.html">LowLevel.h</a> documentation). </dd></dl>

</div>
</div><p>
<a class="anchor" name="a5f0474c7ff1b22626bb015a2e195262"></a><!-- doxytag: member="Events.h::USB_DeviceUnattached" ref="a5f0474c7ff1b22626bb015a2e195262" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USB_DeviceUnattached           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Event for USB device removal. This event fires when a the USB interface is in host mode, and a USB device has been removed the USB interface whether or not it has been enumerated. This can be used to programatically stop the USB management task to reduce CPU consumption.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This event only exists on USB AVR models which supports host mode.<p>
This event does not exist if the USB_DEVICE_ONLY token is supplied to the compiler (see <a class="el" href="../../da/d24/a00068.html">LowLevel.h</a> documentation).</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="../../d9/dec/a00090.html">USBTask.h</a> for more information on the USB management task and reducing CPU usage. </dd></dl>

</div>
</div><p>
<a class="anchor" name="7775f1fb471022d0f6b94d3eee0fe8d0"></a><!-- doxytag: member="Events.h::USB_Disconnect" ref="7775f1fb471022d0f6b94d3eee0fe8d0" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USB_Disconnect           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Event for USB device disconnection. This event fires when the AVR is in USB host mode and an attached and enumerated device has been disconnected, or when in device mode and the device is disconnected from the host.<p>
When in device mode, this can be used to progmatically stop the USB management task to reduce CPU usage.<p>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="../../d9/dec/a00090.html">USBTask.h</a> for more information on the USB management task and reducing CPU usage. </dd></dl>

</div>
</div><p>
<a class="anchor" name="b99a3e845f74ff907bd027f044745fa9"></a><!-- doxytag: member="Events.h::USB_HostError" ref="b99a3e845f74ff907bd027f044745fa9" args="(const uint8_t ErrorCode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USB_HostError           </td>
          <td>(</td>
          <td class="paramtype">const uint8_t&nbsp;</td>
          <td class="paramname"> <em>ErrorCode</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Event for USB host error. This event fires when a hardware fault has occurred whilst the USB interface is in host mode.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ErrorCode</em>&nbsp;</td><td>Error code indicating the failure reason, a value in USB_Host_ErrorCodes_t located in <a class="el" href="../../d4/dca/a00048.html">Host.h</a>.</td></tr>
  </table>
</dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This event only exists on USB AVR models which supports host mode.<p>
This event does not exist if the USB_DEVICE_ONLY token is supplied to the compiler (see <a class="el" href="../../da/d24/a00068.html">LowLevel.h</a> documentation). </dd></dl>

</div>
</div><p>
<a class="anchor" name="a78f34646aecb70b9631a32ad70a1d29"></a><!-- doxytag: member="Events.h::USB_PowerOnFail" ref="a78f34646aecb70b9631a32ad70a1d29" args="(const uint8_t ErrorCode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USB_PowerOnFail           </td>
          <td>(</td>
          <td class="paramtype">const uint8_t&nbsp;</td>
          <td class="paramname"> <em>ErrorCode</em>          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Event for USB device power on failure. This event fires when the USB interface fails to initialize correctly due to a hardware or software fault.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>ErrorCode</em>&nbsp;</td><td>Error code indicating the failure reason, a value in USB_PowerOnErrorCodes_t located in <a class="el" href="../../da/d24/a00068.html">LowLevel.h</a>. </td></tr>
  </table>
</dl>

</div>
</div><p>
<a class="anchor" name="bfc0896707a9437a0c3b0ac611da59aa"></a><!-- doxytag: member="Events.h::USB_Reset" ref="bfc0896707a9437a0c3b0ac611da59aa" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USB_Reset           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Event for USB interface reset. This event fires when a the USB interface is in device mode, and a the USB host requests that the device reset its interface. This is generally hooked so that the USB control endpoint can be switched to interrupt driven mode, by selecting it and calling <a class="el" href="../../db/ddf/a00088.html#975a4f894e655024eb2c09bf9b633416">USB_INT_Enable(ENDPOINT_INT_SETUP)</a>.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This event does not exist if the USB_HOST_ONLY token is supplied to the compiler (see <a class="el" href="../../da/d24/a00068.html">LowLevel.h</a> documentation). </dd></dl>

</div>
</div><p>
<a class="anchor" name="87b4006411b630cc848d30b3e8a53e34"></a><!-- doxytag: member="Events.h::USB_Suspend" ref="87b4006411b630cc848d30b3e8a53e34" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USB_Suspend           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Event for USB suspend. This event fires when a the USB host suspends the device by halting its transmission of Start Of Frame pulses to the device. This is generally hooked in order to move the device over to a low power state until the host wakes up the device.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This event does not exist if the USB_HOST_ONLY token is supplied to the compiler (see <a class="el" href="../../da/d24/a00068.html">LowLevel.h</a> documentation).</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="../../d5/db6/a00042.html#076f3794dcd3ff5b60ad10ea702424ca">USB_WakeUp()</a> event for accompanying Wake Up event. </dd></dl>

</div>
</div><p>
<a class="anchor" name="b97c3ae10c0485db11aaad8103c546eb"></a><!-- doxytag: member="Events.h::USB_UIDChange" ref="b97c3ae10c0485db11aaad8103c546eb" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USB_UIDChange           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Event for USB mode pin level change. This event fires when the USB interface is set to dual role mode, and the UID pin level has changed to indicate a new mode (device or host). This event fires before the mode is switched to the newly indicated mode.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This event only exists on USB AVR models which support dual role modes.<p>
This event does not exist if the USB_DEVICE_ONLY or USB_HOST_ONLY tokens have been supplied to the compiler (see <a class="el" href="../../da/d24/a00068.html">LowLevel.h</a> documentation). </dd></dl>

</div>
</div><p>
<a class="anchor" name="4e4d33dcbef3545a413e1bea0afecbeb"></a><!-- doxytag: member="Events.h::USB_UnhandledControlPacket" ref="4e4d33dcbef3545a413e1bea0afecbeb" args="(const uint8_t bRequest, const uint8_t bmRequestType)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USB_UnhandledControlPacket           </td>
          <td>(</td>
          <td class="paramtype">const uint8_t&nbsp;</td>
          <td class="paramname"> <em>bRequest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t&nbsp;</td>
          <td class="paramname"> <em>bmRequestType</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Event for unhandled control requests. This event fires when a the USB host issues a control request to the control endpoint (address 0) that the library does not handle. This may either be a standard request that the library has no handler code for, or a class specific request issued to the device which must be handled appropriately.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>bRequest</em>&nbsp;</td><td>Request value, indicating what command the host has issued. </td></tr>
    <tr><td valign="top"></td><td valign="top"><em>bmRequestType</em>&nbsp;</td><td>Mask indicating the request data direction (if any), type and recipient.</td></tr>
  </table>
</dl>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This event does not exist if the USB_HOST_ONLY token is supplied to the compiler (see <a class="el" href="../../da/d24/a00068.html">LowLevel.h</a> documentation).<p>
Requests should be handled in the same manner as described in the USB 2.0 Specification, or appropriate class' specification. In all instances, the library has already read the request bmRequestType and bRequest values out (into the Request and RequestType parameters respectively) so that it can correctly determine if it is able to handle the request internally, or hand off the request to the user application via this event. Other request parameters (wValue, wIndex, wLength, and Data) remain in the control endpoint bank until read out by the user application for processing. </dd></dl>

</div>
</div><p>
<a class="anchor" name="253fc995008bf65680601da5deac9d00"></a><!-- doxytag: member="Events.h::USB_VBUSChange" ref="253fc995008bf65680601da5deac9d00" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USB_VBUSChange           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Event for VBUS level change. This event fires when the VBUS line of the USB AVR changes from high to low or vice-versa.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This event is only avaliable on USB AVR models which support VBUS notification interrupts. </dd></dl>

</div>
</div><p>
<a class="anchor" name="edd44878daf24534278acb0a93fb279d"></a><!-- doxytag: member="Events.h::USB_VBUSConnect" ref="edd44878daf24534278acb0a93fb279d" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USB_VBUSConnect           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Event for VBUS attachment. This event fires when the VBUS line of the USB AVR changes from low to high, signalling the attachment of the USB device to a host, before the enumeration process has begun.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This event is only avaliable on USB AVR models which support VBUS notification interrupts. </dd></dl>

</div>
</div><p>
<a class="anchor" name="3d08e81e10a9a4279918317df39c30b9"></a><!-- doxytag: member="Events.h::USB_VBUSDisconnect" ref="3d08e81e10a9a4279918317df39c30b9" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USB_VBUSDisconnect           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Event for VBUS detachment. This event fires when the VBUS line of the USB AVR changes from high to low, signalling the USB device has been removed from a host whether it has been enumerated or not.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This event is only avaliable on USB AVR models which support VBUS notification interrupts. </dd></dl>

</div>
</div><p>
<a class="anchor" name="076f3794dcd3ff5b60ad10ea702424ca"></a><!-- doxytag: member="Events.h::USB_WakeUp" ref="076f3794dcd3ff5b60ad10ea702424ca" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USB_WakeUp           </td>
          <td>(</td>
          <td class="paramtype">void&nbsp;</td>
          <td class="paramname">          </td>
          <td>&nbsp;)&nbsp;</td>
          <td width="100%"></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
Event for USB wake up. This event fires when a the USB interface is suspended while in device mode, and the host wakes up the device by supplying Start Of Frame pulses. This is generally hooked to pull the user application out of a lowe power state and back into normal operating mode.<p>
<dl class="note" compact><dt><b>Note:</b></dt><dd>This event does not exist if the USB_HOST_ONLY token is supplied to the compiler (see <a class="el" href="../../da/d24/a00068.html">LowLevel.h</a> documentation).</dd></dl>
<dl class="see" compact><dt><b>See also:</b></dt><dd><a class="el" href="../../d5/db6/a00042.html#87b4006411b630cc848d30b3e8a53e34">USB_Suspend()</a> event for accompanying Suspend event. </dd></dl>

</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Thu Oct 2 18:01:17 2008 for MyUSB Library by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="../../doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.5 </small></address>
</body>
</html>
