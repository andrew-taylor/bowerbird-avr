<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>MyUSB Library: Getting Started</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.5 -->
<script type="text/javascript">
<!--
function changeDisplayState (e){
  var num=this.id.replace(/[^[0-9]/g,'');
  var button=this.firstChild;
  var sectionDiv=document.getElementById('dynsection'+num);
  if (sectionDiv.style.display=='none'||sectionDiv.style.display==''){
    sectionDiv.style.display='block';
    button.src='open.gif';
  }else{
    sectionDiv.style.display='none';
    button.src='closed.gif';
  }
}
function initDynSections(){
  var divs=document.getElementsByTagName('div');
  var sectionCounter=1;
  for(var i=0;i<divs.length-1;i++){
    if(divs[i].className=='dynheader'&&divs[i+1].className=='dynsection'){
      var header=divs[i];
      var section=divs[i+1];
      var button=header.firstChild;
      if (button!='IMG'){
        divs[i].insertBefore(document.createTextNode(' '),divs[i].firstChild);
        button=document.createElement('img');
        divs[i].insertBefore(button,divs[i].firstChild);
      }
      header.style.cursor='pointer';
      header.onclick=changeDisplayState;
      header.id='dynheader'+sectionCounter;
      button.src='closed.gif';
      section.id='dynsection'+sectionCounter;
      section.style.display='none';
      section.style.marginLeft='14px';
      sectionCounter++;
    }
  }
}
window.onload = initDynSections;
-->
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="classes.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1><a class="anchor" name="Page_GettingStarted">Getting Started </a></h1>Out of the box, MyUSB contains a large number of pre-made class demos for you to test, experiment with and ultimately build upon for your own projects. All the demos come pre-configured to build and run correctly on the AT90USB1287 AVR microcontroller, mounted on the Atmel USBKEY board and running at an 8MHz master clock. This is due to two reasons; one, it is the hardware the author posesses, and two, it is the most popular Atmel USB demonstration board to date.<h2><a class="anchor" name="Sec_Prerequisites">
Prerequisites</a></h2>
Before you can compile any of the MyUSB library code or demos, you will need a recent distribution of avr-libc (1.6.2+) and the AVR-GCC (4.2+) compiler. For Windows users, the best way to obtain these is the WinAVR project (<a href="http://winavr.sourceforge.net">http://winavr.sourceforge.net</a>) as this provides a single-file setup for everything required to compile your own AVR projects.<h2><a class="anchor" name="Sec_Configuring">
Configuring the Demos, Bootloaders and Projects</a></h2>
If the target AVR model, clock speed, board or other settings are different to the current settings, they must be changed and the project recompiled from the source code before being programmed into the AVR microcontroller. Most project configuration options are located in the "makefile" build script inside each MyUSB application's folder, however some demo or application-specific configuration settings (such as the output format in the AudioOut demo) are located in the main .c source file of the project.<p>
Each project "makefile" contains all the script and configuration data required to compile each project. When opened with any regular basic text editor such as Notepad or Wordpad (ensure that the save format is a pure ASCII text format) the build configuration settings may be altered.<p>
Inside each makefile, a number of configuration variables are located, with the format "&lt;VARIABLE NAME&gt; = &lt;VALUE&gt;". For each application, the important variables which should be altered are:<p>
<ul>
<li><b>MCU</b>, the target AVR processor.</li><li><b>BOARD</b>, the target board hardware</li><li><b>F_CPU</b>, the target AVR master clock frequency</li><li><b>CDEFS</b>, the C preprocessor defines which configure the source code</li></ul>
<p>
These values should be changed to reflect the build hardware.<h3><a class="anchor" name="SSec_MCU">
The MCU Parameter</a></h3>
This parameter indicates the target AVR model for the compiled application. This should be set to the model of the target AVR (such as the AT90USB1287, or the ATMEGA32U4), in all lower-case (e.g. "at90usb1287"). Note that not all demos support all the USB AVR models, as they may make use of peripherals or modes only present in some devices.<p>
For supported library AVR models, see main documentation page.<h3><a class="anchor" name="SSec_BOARD">
The BOARD Parameter</a></h3>
This parameter indicates the target AVR board hardware for the compiled application. Some MyUSB library drivers are board-specific, such as the LED driver, and the library needs to know the layout of the target board. If you are using one of the board models listed on the main library page, change this parameter to the board name in all UPPER-case.<p>
If you are not using any board-specific drivers in the MyUSB library, or you are using a custom board layout, change this to read "USER" (no quotes) instead of a standard board name. If the USER board type is selected and the application makes use of one or more board-specific hardware drivers inside the MyUSB library, then the appropriate stub drives files should be copied from the /BoardStubs/ directory into a /Board/ folder inside the application directory, and the stub driver completed with the appropriate code to drive the custom board's hardware.<h3><a class="anchor" name="SSec_F_CPU">
The F_CPU Parameter</a></h3>
This parameter indicates the target AVR's master clock frequency, in Hz. Consult your AVR model's datasheet for allowable clock frequencies if the USB interface is to be operational.<p>
<b>Note that this value does not actually *alter* the AVR's clock frequency</b>, it is just a way to indicate to the library the clock frequency of the AVR as set by the AVR's fuses. If this value does not reflect the actual running frequency of the AVR, incorrect operation of one of more library components will ocurr.<h3><a class="anchor" name="SSec_CDEFS">
The CDEFS Parameter</a></h3>
Most applications will actually have multiple CDEF lines, which are concatenated together with the "+=" operator. This ensures that large numbers of configuration options remain readable by splitting up groups of options into seperate lines.<p>
Normally, these options do not need to be altered to allow an application to compile and run correctly on a different board or AVR to the current configuration - if the options are incorrect, then the demo is most likely incompatible with the chosen USB AVR model and cannot be made to function through the altering of the makefile settings alone (or at all). Settings such as the USB mode (device, host or both), the USB interface speed (Low or Full speed) and other MyUSB configuration options can be set here - refer to the library documentation for details on the configuration parameters.<h2><a class="anchor" name="Sec_Compiling">
Compiling a MyUSB Application</a></h2>
Compiling the MyUSB demos, applications and/or bootloaders is very simple. MyUSB comes with makefile scripts for each individual demo, bootloader and project folder, as well as scripts in the /Demos/, /Bootloaders/, /Projects/ and the MyUSB root directory. This means that compilation can be started from any of the above directories, with a build started from an upper directory in the directory structure executing build of all child directories under it. This means that while a build inside a particular demo directory will build only that particular demo, a build stated from the /Demos/ directory will build all MyUSB demo projects sequentially.<h3><a class="anchor" name="SSec_CommandLine">
Via the Command Line</a></h3>
To build a project from the source via the command line, the command <b>"make all"</b> should be executed from the command line in the directory of interest. To remove compiled files (including the binary output, all intermediatary files and all diagnostic output files), execute <b>"make clean"</b>. Once a "make all" has been run and no errors were encountered, the resulting binary will be located in the generated ".HEX" file. If your project makes use of pre-initialized EEPROM variables, the generated ".EEP" file will contain the project's EEPROM data.<h3><a class="anchor" name="SSec_AVRStudio">
Via AVRStudio</a></h3>
Each demo, project and bootloader contains an AVRStudio project (.aps) which can be used to build each project. Once opened in AVRStudio, the project can be built and cleaned using the GUI buttons or menus. Note that the AVRStudio project files make use of the external project makefile, thus the procedure for configuring a demo remains the same regardless of the build environment.<h2><a class="anchor" name="Sec_Programming">
Programming a USB AVR</a></h2>
Once you have built an application, you will need a way to program in the resulting ".HEX" file (and, if your application uses EEPROM variables with initial values, also a ".EEP" file) into your USB AVR. Normally, the reprogramming an AVR device must be performed using a special piece of programming hardware, through one of the supported AVR programming protocols - ISP, HVSP, HVPP, JTAG or dW. This can be done through a custom programmer, a third party programmer, or an official Atmel AVR tool - for more information, see the Atmel.com website.<p>
Alternatively, you can use the bootloader. From the Atmel factory, each USB AVR comes preloaded with the Atmel DFU (Device Firmware Update) class bootloader, a small piece of AVR firmware which allows the remainder of the AVR to be programmed through a non-standard interface such as the serial USART port, SPI, or (in this case) USB. Bootloaders have the advantage of not requiring any special hardware for programming, and cannot usually be erased or broken without an external programming device. They have disadvantages however; they cannot change the fuses of the AVR (special configuration settings that control the operation of the chip itself) and a small portion of the AVR's FLASH program memory must be reserved to contain the bootloader firmware, and thus cannot be used by the loaded application. Atmel's DFU bootloader is either 4KB (for the smaller USB AVRs) or 8KB (for the larger USB AVRs).<p>
If you wish to use the DFU bootloader to program in your application, refer to your DFU programmer's documentation. Atmel provides a free utility called FLIP which is USB AVR compatible, and an open source (Linux compatible) alternative exists called "dfu-programmer". </div>
<hr size="1"><address style="text-align: right;"><small>Generated on Thu Oct 2 18:01:18 2008 for MyUSB Library by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.5 </small></address>
</body>
</html>
